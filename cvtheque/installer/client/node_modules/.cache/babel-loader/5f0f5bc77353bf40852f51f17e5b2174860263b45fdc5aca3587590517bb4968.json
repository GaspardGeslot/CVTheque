{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*!\n * Built by Revolist\n */\nimport { _ as _baseEach, e as each } from './each.js';\nimport { d as isSymbol_1 } from './isSymbol.js';\nimport { i as identity_1 } from './identity.js';\nimport { _ as _baseIteratee } from './_baseIteratee.js';\nimport { a as isArray_1 } from './keys.js';\nimport { m as mergeSortedArray } from './utils.js';\n\n/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n    length = array == null ? 0 : array.length;\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\nvar _arrayReduce = arrayReduce;\n\n/**\n * The base implementation of `_.reduce` and `_.reduceRight`, without support\n * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} accumulator The initial value.\n * @param {boolean} initAccum Specify using the first or last element of\n *  `collection` as the initial value.\n * @param {Function} eachFunc The function to iterate over `collection`.\n * @returns {*} Returns the accumulated value.\n */\nfunction baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n  eachFunc(collection, function (value, index, collection) {\n    accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);\n  });\n  return accumulator;\n}\nvar _baseReduce = baseReduce;\n\n/**\n * Reduces `collection` to a value which is the accumulated result of running\n * each element in `collection` thru `iteratee`, where each successive\n * invocation is supplied the return value of the previous. If `accumulator`\n * is not given, the first element of `collection` is used as the initial\n * value. The iteratee is invoked with four arguments:\n * (accumulator, value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.reduce`, `_.reduceRight`, and `_.transform`.\n *\n * The guarded methods are:\n * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n * and `sortBy`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @returns {*} Returns the accumulated value.\n * @see _.reduceRight\n * @example\n *\n * _.reduce([1, 2], function(sum, n) {\n *   return sum + n;\n * }, 0);\n * // => 3\n *\n * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n *   (result[value] || (result[value] = [])).push(key);\n *   return result;\n * }, {});\n * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n */\nfunction reduce(collection, iteratee, accumulator) {\n  var func = isArray_1(collection) ? _arrayReduce : _baseReduce,\n    initAccum = arguments.length < 3;\n  return func(collection, _baseIteratee(iteratee), accumulator, initAccum, _baseEach);\n}\nvar reduce_1 = reduce;\n\n/** Used as references for the maximum length and index of an array. */\nvar MAX_ARRAY_LENGTH$1 = 4294967295,\n  MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH$1 - 1;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeFloor = Math.floor,\n  nativeMin = Math.min;\n\n/**\n * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`\n * which invokes `iteratee` for `value` and each element of `array` to compute\n * their sort ranking. The iteratee is invoked with one argument; (value).\n *\n * @private\n * @param {Array} array The sorted array to inspect.\n * @param {*} value The value to evaluate.\n * @param {Function} iteratee The iteratee invoked per element.\n * @param {boolean} [retHighest] Specify returning the highest qualified index.\n * @returns {number} Returns the index at which `value` should be inserted\n *  into `array`.\n */\nfunction baseSortedIndexBy(array, value, iteratee, retHighest) {\n  var low = 0,\n    high = array == null ? 0 : array.length;\n  if (high === 0) {\n    return 0;\n  }\n  value = iteratee(value);\n  var valIsNaN = value !== value,\n    valIsNull = value === null,\n    valIsSymbol = isSymbol_1(value),\n    valIsUndefined = value === undefined;\n  while (low < high) {\n    var mid = nativeFloor((low + high) / 2),\n      computed = iteratee(array[mid]),\n      othIsDefined = computed !== undefined,\n      othIsNull = computed === null,\n      othIsReflexive = computed === computed,\n      othIsSymbol = isSymbol_1(computed);\n    if (valIsNaN) {\n      var setLow = retHighest || othIsReflexive;\n    } else if (valIsUndefined) {\n      setLow = othIsReflexive && (retHighest || othIsDefined);\n    } else if (valIsNull) {\n      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);\n    } else if (valIsSymbol) {\n      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);\n    } else if (othIsNull || othIsSymbol) {\n      setLow = false;\n    } else {\n      setLow = retHighest ? computed <= value : computed < value;\n    }\n    if (setLow) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return nativeMin(high, MAX_ARRAY_INDEX);\n}\nvar _baseSortedIndexBy = baseSortedIndexBy;\n\n/** Used as references for the maximum length and index of an array. */\nvar MAX_ARRAY_LENGTH = 4294967295,\n  HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n\n/**\n * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which\n * performs a binary search of `array` to determine the index at which `value`\n * should be inserted into `array` in order to maintain its sort order.\n *\n * @private\n * @param {Array} array The sorted array to inspect.\n * @param {*} value The value to evaluate.\n * @param {boolean} [retHighest] Specify returning the highest qualified index.\n * @returns {number} Returns the index at which `value` should be inserted\n *  into `array`.\n */\nfunction baseSortedIndex(array, value, retHighest) {\n  var low = 0,\n    high = array == null ? low : array.length;\n  if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n    while (low < high) {\n      var mid = low + high >>> 1,\n        computed = array[mid];\n      if (computed !== null && !isSymbol_1(computed) && (retHighest ? computed <= value : computed < value)) {\n        low = mid + 1;\n      } else {\n        high = mid;\n      }\n    }\n    return high;\n  }\n  return _baseSortedIndexBy(array, value, identity_1, retHighest);\n}\nvar _baseSortedIndex = baseSortedIndex;\n\n/**\n * Uses a binary search to determine the lowest index at which `value`\n * should be inserted into `array` in order to maintain its sort order.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The sorted array to inspect.\n * @param {*} value The value to evaluate.\n * @returns {number} Returns the index at which `value` should be inserted\n *  into `array`.\n * @example\n *\n * _.sortedIndex([30, 50], 40);\n * // => 1\n */\nfunction sortedIndex(array, value) {\n  return _baseSortedIndex(array, value);\n}\nvar sortedIndex_1 = sortedIndex;\n\n/**\n * Pre-calculation\n * Dimension sizes for each cell\n */\nfunction calculateDimensionData(state, newSizes) {\n  let positionIndexes = [];\n  const positionIndexToItem = {};\n  const indexToItem = {};\n  // to compare how real width changed\n  let newTotal = 0;\n  // combine all sizes\n  const sizes = Object.assign(Object.assign({}, state.sizes), newSizes);\n  // prepare order sorted new sizes and calculate changed real size\n  let newIndexes = [];\n  each(newSizes, (size, index) => {\n    // if first introduced custom size\n    if (!state.sizes[index]) {\n      newTotal += size - (state.realSize ? state.originItemSize : 0);\n      newIndexes.splice(sortedIndex_1(newIndexes, parseInt(index, 10)), 0, parseInt(index, 10));\n    } else {\n      newTotal += size - state.sizes[index];\n    }\n  });\n  // add order to cached order collection for faster linking\n  const updatedIndexesCache = mergeSortedArray(state.indexes, newIndexes);\n  // fill new coordinates\n  reduce_1(updatedIndexesCache, (previous, itemIndex, i) => {\n    const newItem = {\n      itemIndex,\n      start: 0,\n      end: 0\n    };\n    if (previous) {\n      newItem.start = (itemIndex - previous.itemIndex - 1) * state.originItemSize + previous.end;\n    } else {\n      newItem.start = itemIndex * state.originItemSize;\n    }\n    newItem.end = newItem.start + sizes[itemIndex];\n    positionIndexes.push(newItem.start);\n    indexToItem[itemIndex] = positionIndexToItem[i] = newItem;\n    return newItem;\n  }, undefined);\n  return {\n    indexes: updatedIndexesCache,\n    positionIndexes: [...positionIndexes],\n    positionIndexToItem: Object.assign({}, positionIndexToItem),\n    indexToItem,\n    realSize: state.realSize + newTotal,\n    sizes\n  };\n}\nfunction getItemByPosition({\n  indexes,\n  positionIndexes,\n  originItemSize,\n  positionIndexToItem\n}, pos) {\n  const item = {\n    itemIndex: 0,\n    start: 0,\n    end: 0\n  };\n  const currentPlace = indexes.length ? sortedIndex_1(positionIndexes, pos) : 0;\n  // not found or first index\n  if (!currentPlace) {\n    item.itemIndex = Math.floor(pos / originItemSize);\n    item.start = item.itemIndex * originItemSize;\n    item.end = item.start + originItemSize;\n    return item;\n  }\n  const positionItem = positionIndexToItem[currentPlace - 1];\n  // if item has specified size\n  if (positionItem.end > pos) {\n    return positionItem;\n  }\n  // special size item was present before\n  const relativePos = pos - positionItem.end;\n  const relativeIndex = Math.floor(relativePos / originItemSize);\n  item.itemIndex = positionItem.itemIndex + 1 + relativeIndex;\n  item.start = positionItem.end + relativeIndex * originItemSize;\n  item.end = item.start + originItemSize;\n  return item;\n}\nfunction getItemByIndex(dimension, index) {\n  let item = {\n    itemIndex: index,\n    start: 0,\n    end: 0\n  };\n  // if item has specified size\n  if (dimension.indexToItem[index]) {\n    return dimension.indexToItem[index];\n  }\n  const currentPlace = dimension.indexes.length ? sortedIndex_1(dimension.indexes, index) : 0;\n  // not found or first index\n  if (!currentPlace) {\n    item.start = item.itemIndex * dimension.originItemSize;\n    item.end = item.start + dimension.originItemSize;\n    return item;\n  }\n  // special size item was present before\n  const positionItem = dimension.indexToItem[dimension.indexes[currentPlace - 1]];\n  item.start = positionItem.end + (index - positionItem.itemIndex - 1) * dimension.originItemSize;\n  item.end = item.start + dimension.originItemSize;\n  return item;\n}\nexport { getItemByPosition as a, calculateDimensionData as c, getItemByIndex as g, reduce_1 as r };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
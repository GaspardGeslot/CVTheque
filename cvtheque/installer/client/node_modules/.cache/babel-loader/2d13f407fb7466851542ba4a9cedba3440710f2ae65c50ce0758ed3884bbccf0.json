{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*!\n * Built by Revolist\n */\nimport { proxyCustomElement, HTMLElement, createEvent, h, Host } from '@stencil/core/internal/client';\nimport { c as createStore, d as setStore, D as DataStore } from './data.store.js';\nimport { a as getItemByPosition } from './dimension.helpers.js';\nimport { U as UUID } from './consts.js';\nimport { d as defineCustomElement$3 } from './revogr-data2.js';\nimport { a as defineCustomElement$2 } from './revogr-header2.js';\nimport { d as defineCustomElement$1 } from './revogr-viewport-scroll2.js';\n\n/**\n * Update items based on new scroll position\n * If viewport wasn't changed fully simple recombination of positions\n * Otherwise rebuild viewport items\n */\nfunction getUpdatedItemsByPosition(pos, items, realCount, virtualSize, dimension) {\n  const activeItem = getItemByPosition(dimension, pos);\n  const firstItem = getFirstItem(items);\n  let toUpdate;\n  // do simple position replacement if items already present in viewport\n  if (firstItem) {\n    let changedOffsetStart = activeItem.itemIndex - (firstItem.itemIndex || 0);\n    if (changedOffsetStart) {\n      // simple recombination\n      const newData = recombineByOffset(Math.abs(changedOffsetStart), Object.assign(Object.assign({\n        positiveDirection: changedOffsetStart > -1\n      }, dimension), items));\n      if (newData) {\n        toUpdate = newData;\n      }\n      // if partial replacement add items if revo-viewport has some space left\n      if (toUpdate) {\n        const extra = addMissingItems(activeItem, realCount, virtualSize, toUpdate, dimension);\n        if (extra.length) {\n          updateMissingAndRange(toUpdate.items, extra, toUpdate);\n        }\n      }\n    }\n  }\n  // new collection if no items after replacement full replacement\n  if (!toUpdate) {\n    const items = getItems({\n      start: activeItem.start,\n      startIndex: activeItem.itemIndex,\n      origSize: dimension.originItemSize,\n      maxSize: virtualSize,\n      maxCount: realCount,\n      sizes: dimension.sizes\n    });\n    // range now comes from 0 to length - 1\n    toUpdate = {\n      items,\n      start: 0,\n      end: items.length - 1\n    };\n  }\n  return toUpdate;\n}\nfunction updateMissingAndRange(items, missing, range) {\n  items.splice(range.end + 1, 0, ...missing);\n  // update range if start larger after recombination\n  if (range.start >= range.end && !(range.start === range.end && range.start === 0)) {\n    range.start += missing.length;\n  }\n  range.end += missing.length;\n}\n// if partial replacement add items if revo-viewport has some space left\nfunction addMissingItems(firstItem, realCount, virtualSize, existingCollection, dimension) {\n  const lastItem = getLastItem(existingCollection);\n  const items = getItems({\n    sizes: dimension.sizes,\n    start: lastItem.end,\n    startIndex: lastItem.itemIndex + 1,\n    origSize: dimension.originItemSize,\n    maxSize: virtualSize - (lastItem.end - firstItem.start),\n    maxCount: realCount\n  });\n  return items;\n}\n// get revo-viewport items parameters, caching position and calculating items count in revo-viewport\nfunction getItems(opt, currentSize = 0) {\n  const items = [];\n  let index = opt.startIndex;\n  let size = currentSize;\n  while (size <= opt.maxSize && index < opt.maxCount) {\n    const newSize = getItemSize(index, opt.sizes, opt.origSize);\n    items.push({\n      start: opt.start + size,\n      end: opt.start + size + newSize,\n      itemIndex: index,\n      size: newSize\n    });\n    size += newSize;\n    index++;\n  }\n  return items;\n}\n/**\n * Do batch items recombination\n * If items not overlapped with existing viewport returns null\n */\nfunction recombineByOffset(offset, data) {\n  const newItems = [...data.items];\n  const itemsCount = newItems.length;\n  let newRange = {\n    start: data.start,\n    end: data.end\n  };\n  // if offset out of revo-viewport, makes sense whole redraw\n  if (offset > itemsCount) {\n    return null;\n  }\n  // is direction of scroll positive\n  if (data.positiveDirection) {\n    // push item to the end\n    let lastItem = getLastItem(data);\n    let i = newRange.start;\n    const length = i + offset;\n    for (; i < length; i++) {\n      const newIndex = lastItem.itemIndex + 1;\n      const size = getItemSize(newIndex, data.sizes, data.originItemSize);\n      // if item overlapped limit break a loop\n      if (lastItem.end + size > data.realSize) {\n        break;\n      }\n      // new item index to recombine\n      let newEnd = i % itemsCount;\n      // item should always present, we do not create new item, we recombine them\n      if (!newItems[newEnd]) {\n        throw new Error('incorrect index');\n      }\n      // do recombination\n      newItems[newEnd] = lastItem = {\n        start: lastItem.end,\n        end: lastItem.end + size,\n        itemIndex: newIndex,\n        size: size\n      };\n      // update range\n      newRange.start++;\n      newRange.end = newEnd;\n    }\n    // direction is negative\n  } else {\n    // push item to the start\n    let firstItem = getFirstItem(data);\n    const end = newRange.end;\n    for (let i = 0; i < offset; i++) {\n      const newIndex = firstItem.itemIndex - 1;\n      const size = getItemSize(newIndex, data.sizes, data.originItemSize);\n      // new item index to recombine\n      let newStart = end - i;\n      newStart = (newStart < 0 ? itemsCount + newStart : newStart) % itemsCount;\n      // item should always present, we do not create new item, we recombine them\n      if (!newItems[newStart]) {\n        throw new Error('incorrect index');\n      }\n      // do recombination\n      newItems[newStart] = firstItem = {\n        start: firstItem.start - size,\n        end: firstItem.start,\n        itemIndex: newIndex,\n        size: size\n      };\n      // update range\n      newRange.start = newStart;\n      newRange.end--;\n    }\n  }\n  const range = {\n    start: (newRange.start < 0 ? itemsCount + newRange.start : newRange.start) % itemsCount,\n    end: (newRange.end < 0 ? itemsCount + newRange.end : newRange.end) % itemsCount\n  };\n  return Object.assign({\n    items: newItems\n  }, range);\n}\nfunction getItemSize(index, sizes, origSize = 0) {\n  if (sizes && sizes[index]) {\n    return sizes[index];\n  }\n  return origSize;\n}\nfunction isActiveRange(pos, item) {\n  return item && pos >= item.start && pos <= item.end;\n}\nfunction getFirstItem(s) {\n  return s.items[s.start];\n}\nfunction getLastItem(s) {\n  return s.items[s.end];\n}\n\n/**\n * Store is responsible for visible\n * Viewport information for each dimension\n * Redraw items during scrolling\n */\nfunction initialState() {\n  return {\n    // virtual item information per rendered item\n    items: [],\n    // virtual dom item order to render\n    start: 0,\n    end: 0,\n    // size of viewport in px\n    virtualSize: 0,\n    // total number of items\n    realCount: 0,\n    // last coordinate for store position restore\n    lastCoordinate: 0\n  };\n}\nclass ViewportStore {\n  constructor() {\n    this.store = createStore(initialState());\n    this.store.onChange('realCount', () => this.clear());\n  }\n  /** Render viewport based on coordinate, this is main method for draw */\n  setViewPortCoordinate(position, dimension) {\n    let virtualSize = this.store.get('virtualSize');\n    // no visible data to calculate\n    if (!virtualSize) {\n      return;\n    }\n    const frameOffset = dimension.frameOffset;\n    const outsize = frameOffset * 2 * dimension.originItemSize;\n    virtualSize += outsize;\n    let maxCoordinate = virtualSize;\n    if (dimension.realSize > virtualSize) {\n      maxCoordinate = dimension.realSize - virtualSize;\n    }\n    let toUpdate = {\n      lastCoordinate: position\n    };\n    let pos = position;\n    pos -= frameOffset * dimension.originItemSize;\n    pos = pos < 0 ? 0 : pos < maxCoordinate ? pos : maxCoordinate;\n    const firstItem = getFirstItem(this.getItems());\n    const lastItem = getLastItem(this.getItems());\n    // left position changed\n    if (!isActiveRange(pos, firstItem)) {\n      toUpdate = Object.assign(Object.assign({}, toUpdate), getUpdatedItemsByPosition(pos, this.getItems(), this.store.get('realCount'), virtualSize, dimension));\n      setStore(this.store, Object.assign({}, toUpdate));\n      // right position changed\n    } else if (firstItem && this.store.get('virtualSize') + pos > (lastItem === null || lastItem === void 0 ? void 0 : lastItem.end)) {\n      // check is any item missing for full fill content\n      const missing = addMissingItems(firstItem, this.store.get('realCount'), virtualSize + pos - firstItem.start, this.getItems(), dimension);\n      if (missing.length) {\n        const items = [...this.store.get('items')];\n        const range = {\n          start: this.store.get('start'),\n          end: this.store.get('end')\n        };\n        updateMissingAndRange(items, missing, range);\n        toUpdate = Object.assign(Object.assign(Object.assign({}, toUpdate), {\n          items: [...items]\n        }), range);\n        setStore(this.store, Object.assign({}, toUpdate));\n      }\n    }\n  }\n  /** Update viewport sizes */\n  setViewPortDimension(sizes) {\n    const items = this.store.get('items');\n    const count = items.length;\n    // viewport not inited\n    if (!count) {\n      return;\n    }\n    let changedCoordinate = 0;\n    let i = 0;\n    let start = this.store.get('start');\n    // loop through array from initial item after recombination\n    while (i < count) {\n      const item = items[start];\n      // change pos if size change present before\n      if (changedCoordinate) {\n        item.start += changedCoordinate;\n        item.end += changedCoordinate;\n      }\n      // change size\n      const size = sizes[item.itemIndex];\n      if (size) {\n        const changedSize = size - item.size;\n        changedCoordinate += changedSize;\n        item.size = size;\n        item.end = item.start + size;\n      }\n      // loop by start index\n      start++;\n      i++;\n      if (start === count) {\n        start = 0;\n      }\n    }\n    setStore(this.store, {\n      items: [...items]\n    });\n  }\n  getItems() {\n    return {\n      items: this.store.get('items'),\n      start: this.store.get('start'),\n      end: this.store.get('end')\n    };\n  }\n  setViewport(data) {\n    setStore(this.store, data);\n  }\n  clear() {\n    this.store.set('items', []);\n  }\n}\nconst RowHeaderRender = s => (__, {\n  rowIndex: i\n}) => s + i;\nconst LETTER_BLOCK_SIZE = 10;\nconst RevogrRowHeaders = /*@__PURE__*/proxyCustomElement(class extends HTMLElement {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.scrollViewport = createEvent(this, \"scrollViewport\", 3);\n    this.elementToScroll = createEvent(this, \"elementToScroll\", 3);\n  }\n  render() {\n    var _a;\n    const dataViews = [];\n    const viewport = new ViewportStore();\n    /** render viewports rows */\n    let totalLength = 1;\n    for (let data of this.dataPorts) {\n      const itemCount = data.dataStore.get('items').length;\n      // initiate row data\n      const dataStore = new DataStore(data.type);\n      dataStore.updateData(data.dataStore.get('source'));\n      // initiate column data\n      const colData = new DataStore('colPinStart');\n      const column = Object.assign({\n        cellTemplate: RowHeaderRender(totalLength)\n      }, this.rowHeaderColumn);\n      colData.updateData([column]);\n      const viewData = Object.assign(Object.assign({}, data), {\n        dataStore: dataStore.store,\n        colData: colData.store,\n        viewportCol: viewport.store,\n        readonly: true,\n        range: false\n      });\n      dataViews.push(h(\"revogr-data\", Object.assign({}, viewData)));\n      totalLength += itemCount;\n    }\n    const colSize = ((_a = this.rowHeaderColumn) === null || _a === void 0 ? void 0 : _a.size) || (totalLength.toString().length + 1) * LETTER_BLOCK_SIZE;\n    viewport.setViewport({\n      realCount: 1,\n      virtualSize: 0,\n      items: [{\n        size: colSize,\n        start: 0,\n        end: colSize,\n        itemIndex: 0\n      }]\n    });\n    const parent = `${this.uiid}-rowHeaders`;\n    const viewportScroll = {\n      [UUID]: parent,\n      contentHeight: this.height,\n      contentWidth: 0,\n      style: {\n        minWidth: `${colSize}px`\n      },\n      ref: el => this.elementToScroll.emit(el),\n      onScrollViewport: e => this.scrollViewport.emit(e.detail)\n    };\n    const viewportHeader = Object.assign(Object.assign({}, this.headerProp), {\n      colData: typeof this.rowHeaderColumn === 'object' ? [this.rowHeaderColumn] : [],\n      viewportCol: viewport.store,\n      canResize: false,\n      parent,\n      slot: 'header'\n    });\n    return h(Host, {\n      class: \"rowHeaders\",\n      key: \"rowHeaders\"\n    }, h(\"revogr-viewport-scroll\", Object.assign({}, viewportScroll), h(\"revogr-header\", Object.assign({}, viewportHeader)), dataViews));\n  }\n}, [0, \"revogr-row-headers\", {\n  \"height\": [2],\n  \"dataPorts\": [16],\n  \"headerProp\": [16],\n  \"uiid\": [1],\n  \"resize\": [4],\n  \"rowHeaderColumn\": [16]\n}]);\nfunction defineCustomElement() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"revogr-row-headers\", \"revogr-data\", \"revogr-header\", \"revogr-viewport-scroll\"];\n  components.forEach(tagName => {\n    switch (tagName) {\n      case \"revogr-row-headers\":\n        if (!customElements.get(tagName)) {\n          customElements.define(tagName, RevogrRowHeaders);\n        }\n        break;\n      case \"revogr-data\":\n        if (!customElements.get(tagName)) {\n          defineCustomElement$3();\n        }\n        break;\n      case \"revogr-header\":\n        if (!customElements.get(tagName)) {\n          defineCustomElement$2();\n        }\n        break;\n      case \"revogr-viewport-scroll\":\n        if (!customElements.get(tagName)) {\n          defineCustomElement$1();\n        }\n        break;\n    }\n  });\n}\ndefineCustomElement();\nexport { RevogrRowHeaders as R, ViewportStore as V, defineCustomElement as d };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
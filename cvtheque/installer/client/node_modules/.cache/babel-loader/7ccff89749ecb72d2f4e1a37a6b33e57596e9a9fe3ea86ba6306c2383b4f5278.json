{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*!\n * Built by Revolist\n */\nimport { h, proxyCustomElement, HTMLElement, createEvent, Host } from '@stencil/core/internal/client';\nimport { r as reduce_1, c as calculateDimensionData, g as getItemByIndex, a as getItemByPosition } from './dimension.helpers.js';\nimport { _ as _baseEach, e as each } from './each.js';\nimport { _ as _baseIteratee, a as _baseProperty, b as _getTag } from './_baseIteratee.js';\nimport { i as isArrayLike_1, k as keys_1, a as isArray_1, _ as _baseKeys } from './keys.js';\nimport { f as findIndex_1, g as getSourceItem, a as getSourceItemVirtualIndexByProp, s as setSourceByVirtualIndex, D as DataStore, b as getVisibleSourceItem, c as createStore, d as setStore, _ as _isIterateeCall, e as getPhysical, h as setItems } from './data.store.js';\nimport { _ as _arrayMap, U as UUID } from './consts.js';\nimport { V as ViewportStore, d as defineCustomElement$5 } from './revogr-row-headers2.js';\nimport { t as timeout, g as getScrollbarWidth } from './utils.js';\nimport { i as isFilterBtn, F as FILTER_PROP } from './filter.button.js';\nimport { i as isString_1, d as defineCustomElement$a } from './revogr-edit2.js';\nimport { t as toInteger_1 } from './toInteger.js';\nimport { i as isGrouping, g as getGroupingName, G as GROUP_EXPANDED, a as getParsedGroup, b as isSameGroup, c as GROUP_DEPTH, P as PSEUDO_GROUP_ITEM_VALUE, d as PSEUDO_GROUP_ITEM_ID, e as GROUPING_ROW_TYPE, f as PSEUDO_GROUP_COLUMN, h as GROUP_EXPAND_EVENT, j as gatherGrouping, k as isGroupingColumn, E as EMPTY_INDEX, S as SelectionStoreConnector } from './columnService.js';\nimport { g as getLastCell, H as HEADER_SLOT, C as CONTENT_SLOT, F as FOOTER_SLOT, D as DATA_SLOT, d as defineCustomElement$2 } from './revogr-viewport-scroll2.js';\nimport { l as lodash, d as defineCustomElement$3 } from './revogr-temp-range2.js';\nimport { d as debounce_1 } from './debounce.js';\nimport { d as dispatch, a as defineCustomElement$8 } from './revogr-header2.js';\nimport { d as defineCustomElement$b } from './revogr-data2.js';\nimport { d as defineCustomElement$9 } from './revogr-focus2.js';\nimport { d as defineCustomElement$7 } from './revogr-order-editor2.js';\nimport { d as defineCustomElement$6 } from './revogr-overlay-selection2.js';\nimport { d as defineCustomElement$4 } from './revogr-scroll-virtual2.js';\nclass ThemeCompact {\n  constructor() {\n    this.defaultRowSize = 32;\n  }\n}\nclass ThemeDefault {\n  constructor() {\n    this.defaultRowSize = 27;\n  }\n}\nclass ThemeMaterial {\n  constructor() {\n    this.defaultRowSize = 42;\n  }\n}\nconst DEFAULT_THEME = 'default';\nconst allowedThemes = [DEFAULT_THEME, 'material', 'compact', 'darkMaterial', 'darkCompact'];\nclass ThemeService {\n  constructor(cfg) {\n    this.customRowSize = 0;\n    this.customRowSize = cfg.rowSize;\n    this.register('default');\n  }\n  get theme() {\n    return this.currentTheme;\n  }\n  get rowSize() {\n    return this.customRowSize || this.currentTheme.defaultRowSize;\n  }\n  set rowSize(size) {\n    this.customRowSize = size;\n  }\n  register(theme) {\n    const parsedTheme = ThemeService.getTheme(theme);\n    switch (parsedTheme) {\n      case 'material':\n      case 'darkMaterial':\n        this.currentTheme = new ThemeMaterial();\n        break;\n      case 'compact':\n      case 'darkCompact':\n        this.currentTheme = new ThemeCompact();\n        break;\n      default:\n        this.currentTheme = new ThemeDefault();\n        break;\n    }\n  }\n  static getTheme(theme) {\n    if (allowedThemes.indexOf(theme) > -1) {\n      return theme;\n    }\n    return DEFAULT_THEME;\n  }\n}\n\n/**\n * Creates a `_.find` or `_.findLast` function.\n *\n * @private\n * @param {Function} findIndexFunc The function to find the collection index.\n * @returns {Function} Returns the new find function.\n */\nfunction createFind(findIndexFunc) {\n  return function (collection, predicate, fromIndex) {\n    var iterable = Object(collection);\n    if (!isArrayLike_1(collection)) {\n      var iteratee = _baseIteratee(predicate);\n      collection = keys_1(collection);\n      predicate = function (key) {\n        return iteratee(iterable[key], key, iterable);\n      };\n    }\n    var index = findIndexFunc(collection, predicate, fromIndex);\n    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n  };\n}\nvar _createFind = createFind;\n\n/**\n * Iterates over elements of `collection`, returning the first element\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {*} Returns the matched element, else `undefined`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'age': 36, 'active': true },\n *   { 'user': 'fred',    'age': 40, 'active': false },\n *   { 'user': 'pebbles', 'age': 1,  'active': true }\n * ];\n *\n * _.find(users, function(o) { return o.age < 40; });\n * // => object for 'barney'\n *\n * // The `_.matches` iteratee shorthand.\n * _.find(users, { 'age': 1, 'active': true });\n * // => object for 'pebbles'\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.find(users, ['active', false]);\n * // => object for 'fred'\n *\n * // The `_.property` iteratee shorthand.\n * _.find(users, 'active');\n * // => object for 'barney'\n */\nvar find = _createFind(findIndex_1);\nvar find_1 = find;\nconst rowTypes = ['rowPinStart', 'rgRow', 'rowPinEnd'];\nconst columnTypes = ['colPinStart', 'rgCol', 'colPinEnd'];\nfunction isRowType(type) {\n  return rowTypes.indexOf(type) > -1;\n}\n\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction baseMap(collection, iteratee) {\n  var index = -1,\n    result = isArrayLike_1(collection) ? Array(collection.length) : [];\n  _baseEach(collection, function (value, key, collection) {\n    result[++index] = iteratee(value, key, collection);\n  });\n  return result;\n}\nvar _baseMap = baseMap;\n\n/**\n * Creates an array of values by running each element in `collection` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n *\n * The guarded methods are:\n * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n * @example\n *\n * function square(n) {\n *   return n * n;\n * }\n *\n * _.map([4, 8], square);\n * // => [16, 64]\n *\n * _.map({ 'a': 4, 'b': 8 }, square);\n * // => [16, 64] (iteration order is not guaranteed)\n *\n * var users = [\n *   { 'user': 'barney' },\n *   { 'user': 'fred' }\n * ];\n *\n * // The `_.property` iteratee shorthand.\n * _.map(users, 'user');\n * // => ['barney', 'fred']\n */\nfunction map(collection, iteratee) {\n  var func = isArray_1(collection) ? _arrayMap : _baseMap;\n  return func(collection, _baseIteratee(iteratee));\n}\nvar map_1 = map;\nclass BasePlugin {\n  constructor(revogrid) {\n    this.revogrid = revogrid;\n    this.subscriptions = {};\n  }\n  addEventListener(name, func) {\n    this.revogrid.addEventListener(name, func);\n    this.subscriptions[name] = func;\n  }\n  removeEventListener(type) {\n    this.revogrid.removeEventListener(type, this.subscriptions[type]);\n    delete this.subscriptions[type];\n  }\n  emit(eventName, detail) {\n    const event = new CustomEvent(eventName, {\n      detail: detail,\n      cancelable: true\n    });\n    this.revogrid.dispatchEvent(event);\n    return event;\n  }\n  clearSubscriptions() {\n    for (let type in this.subscriptions) {\n      this.removeEventListener(type);\n    }\n  }\n  destroy() {\n    this.clearSubscriptions();\n  }\n}\nclass GroupingColumnPlugin extends BasePlugin {\n  static gatherGroup(res, colData, collection, level = 0) {\n    // group template\n    const group = Object.assign(Object.assign({}, colData), {\n      level,\n      ids: []\n    });\n    // check columns for update\n    for (let k in collection.columns) {\n      const key = k;\n      const resultItem = res.columns[key];\n      const collectionItem = collection.columns[key];\n      // if column data\n      if (isArray_1(resultItem) && isArray_1(collectionItem)) {\n        // fill columns\n        resultItem.push(...collectionItem);\n        // fill grouping\n        if (collectionItem.length) {\n          res.columnGrouping[key].push(Object.assign(Object.assign({}, group), {\n            ids: map_1(collectionItem, 'prop')\n          }));\n        }\n      }\n    }\n    // merge column groupings\n    for (let k in collection.columnGrouping) {\n      const key = k;\n      const collectionItem = collection.columnGrouping[key];\n      res.columnGrouping[key].push(...collectionItem);\n    }\n    res.maxLevel = Math.max(res.maxLevel, collection.maxLevel);\n    res.sort = Object.assign(Object.assign({}, res.sort), collection.sort);\n    return res;\n  }\n}\nfunction isColGrouping(colData) {\n  return !!colData.children;\n}\nclass ColumnDataProvider {\n  constructor() {\n    this.sorting = null;\n    this.dataSources = reduce_1(columnTypes, (sources, k) => {\n      sources[k] = new DataStore(k);\n      return sources;\n    }, {});\n  }\n  get order() {\n    return reduce_1(this.sorting, (r, c, prop) => {\n      r[prop] = c.order;\n      return r;\n    }, {});\n  }\n  get stores() {\n    return this.dataSources;\n  }\n  column(c, pin) {\n    return this.getColumn(c, pin || 'rgCol');\n  }\n  getColumn(virtualIndex, type) {\n    return getSourceItem(this.dataSources[type].store, virtualIndex);\n  }\n  getRawColumns() {\n    return reduce_1(this.dataSources, (result, item, type) => {\n      result[type] = item.store.get('source');\n      return result;\n    }, {\n      rgCol: [],\n      colPinStart: [],\n      colPinEnd: []\n    });\n  }\n  getColumns(type = 'all') {\n    if (type !== 'all') {\n      return this.dataSources[type].store.get('source');\n    }\n    return columnTypes.reduce((r, t) => {\n      r.push(...this.dataSources[t].store.get('source'));\n      return r;\n    }, []);\n  }\n  getColumnIndexByProp(prop, type) {\n    return getSourceItemVirtualIndexByProp(this.dataSources[type].store, prop);\n  }\n  getColumnByProp(prop, type) {\n    const items = this.dataSources[type].store.get('source');\n    return find_1(items, {\n      prop\n    });\n  }\n  refreshByType(type) {\n    this.dataSources[type].refresh();\n  }\n  setColumns(data) {\n    each(columnTypes, k => {\n      // set columns data\n      this.dataSources[k].updateData(data.columns[k], {\n        // max depth level\n        depth: data.maxLevel,\n        // groups\n        groups: reduce_1(data.columnGrouping[k], (res, g) => {\n          if (!res[g.level]) {\n            res[g.level] = [];\n          }\n          res[g.level].push(g);\n          return res;\n        }, {})\n      });\n    });\n    this.sorting = data.sort;\n    return data;\n  }\n  updateColumns(cols) {\n    // collect column by type and propert\n    const columnByKey = cols.reduce((res, c) => {\n      const type = ColumnDataProvider.getColumnType(c);\n      if (!res[type]) {\n        res[type] = {};\n      }\n      res[type][c.prop] = c;\n      return res;\n    }, {});\n    // find indexes in source\n    const colByIndex = {};\n    each(columnByKey, (colsToUpdate, type) => {\n      const items = this.dataSources[type].store.get('source');\n      colByIndex[type] = items.reduce((result, rgCol, index) => {\n        const colToUpdateIfExists = colsToUpdate[rgCol.prop];\n        if (colToUpdateIfExists) {\n          result[index] = colToUpdateIfExists;\n        }\n        return result;\n      }, {});\n    });\n    each(colByIndex, (colsToUpdate, type) => setSourceByVirtualIndex(this.dataSources[type].store, colsToUpdate));\n  }\n  updateColumn(column, index) {\n    const type = ColumnDataProvider.getColumnType(column);\n    setSourceByVirtualIndex(this.dataSources[type].store, {\n      [index]: column\n    });\n  }\n  updateColumnSorting(column, index, sorting, additive) {\n    if (!additive) {\n      this.clearSorting();\n    }\n    column.order = sorting;\n    this.sorting[column.prop] = column;\n    this.updateColumn(column, index);\n    return column;\n  }\n  clearSorting() {\n    const types = reduce_1(this.sorting, (r, c) => {\n      const k = ColumnDataProvider.getColumnType(c);\n      r[k] = true;\n      return r;\n    }, {});\n    each(types, (_, type) => {\n      const cols = this.dataSources[type].store.get('source');\n      each(cols, c => c.order = undefined);\n      this.dataSources[type].setData({\n        source: [...cols]\n      });\n    });\n    this.sorting = {};\n  }\n  static getSizes(cols) {\n    return reduce_1(cols, (res, c, i) => {\n      if (c.size) {\n        res[i] = c.size;\n      }\n      return res;\n    }, {});\n  }\n  static getColumnByProp(columns, prop) {\n    return find_1(columns, c => {\n      if (isColGrouping(c)) {\n        return ColumnDataProvider.getColumnByProp(c.children, prop);\n      }\n      return c.prop === prop;\n    });\n  }\n  // columns processing\n  static getColumns(columns, level = 0, types) {\n    return reduce_1(columns, (res, colData) => {\n      /** Grouped column */\n      if (isColGrouping(colData)) {\n        return GroupingColumnPlugin.gatherGroup(res, colData, ColumnDataProvider.getColumns(colData.children, level + 1, types), level);\n      }\n      /** Regular column */\n      const regularColumn = Object.assign(Object.assign({}, colData.columnType && types && types[colData.columnType]), colData);\n      // not pin\n      if (!regularColumn.pin) {\n        res.columns.rgCol.push(regularColumn);\n        // pin\n      } else {\n        res.columns[regularColumn.pin].push(regularColumn);\n      }\n      if (regularColumn.order) {\n        res.sort[regularColumn.prop] = regularColumn;\n      }\n      // trigger setup hook if present\n      regularColumn.beforeSetup && regularColumn.beforeSetup(regularColumn);\n      return res;\n    }, {\n      columns: {\n        rgCol: [],\n        colPinStart: [],\n        colPinEnd: []\n      },\n      columnGrouping: {\n        rgCol: [],\n        colPinStart: [],\n        colPinEnd: []\n      },\n      maxLevel: level,\n      sort: {}\n    });\n  }\n  static getColumnType(rgCol) {\n    if (rgCol.pin) {\n      return rgCol.pin;\n    }\n    return 'rgCol';\n  }\n}\nclass DataProvider {\n  constructor(dimensionProvider) {\n    this.dimensionProvider = dimensionProvider;\n    this.stores = reduce_1(rowTypes, (sources, k) => {\n      sources[k] = new DataStore(k);\n      return sources;\n    }, {});\n  }\n  setData(data, type = 'rgRow', grouping, silent = false) {\n    // set rgRow data\n    this.stores[type].updateData([...data], grouping, silent);\n    this.dimensionProvider.setData(data, type, type !== 'rgRow');\n    return data;\n  }\n  getModel(virtualIndex, type = 'rgRow') {\n    const store = this.stores[type].store;\n    return getSourceItem(store, virtualIndex);\n  }\n  setCellData({\n    type,\n    rowIndex,\n    prop,\n    val\n  }) {\n    const model = this.getModel(rowIndex, type);\n    model[prop] = val;\n    setSourceByVirtualIndex(this.stores[type].store, {\n      [rowIndex]: model\n    });\n  }\n  refresh(type = 'all') {\n    if (isRowType(type)) {\n      this.refreshItems(type);\n    }\n    rowTypes.forEach(t => this.refreshItems(t));\n  }\n  refreshItems(type = 'rgRow') {\n    const items = this.stores[type].store.get('items');\n    this.stores[type].setData({\n      items: [...items]\n    });\n  }\n  setGrouping({\n    depth\n  }, type = 'rgRow') {\n    this.stores[type].setData({\n      groupingDepth: depth\n    });\n  }\n  setTrimmed(trimmed, type = 'rgRow') {\n    const store = this.stores[type];\n    store.addTrimmed(trimmed);\n    if (type === 'rgRow') {\n      this.dimensionProvider.setData(getVisibleSourceItem(store.store), type);\n    }\n  }\n}\n\n/**\n * Storing pre-calculated\n * Dimension information and sizes\n */\nfunction initialBase() {\n  return {\n    indexes: [],\n    // item index to size\n    sizes: {},\n    // order in indexes[] to coordinate\n    positionIndexToItem: {},\n    // initial element to coordinate ^\n    indexToItem: {},\n    positionIndexes: []\n  };\n}\nfunction initialState() {\n  return Object.assign(Object.assign({}, initialBase()), {\n    // size which all items can take\n    realSize: 0,\n    // initial item size if it wasn't changed\n    originItemSize: 0,\n    frameOffset: 0\n  });\n}\nclass DimensionStore {\n  constructor() {\n    this.store = createStore(initialState());\n  }\n  getCurrentState() {\n    const state = initialState();\n    const keys = Object.keys(state);\n    return reduce_1(keys, (r, k) => {\n      const data = this.store.get(k);\n      r[k] = data;\n      return r;\n    }, state);\n  }\n  setRealSize(count) {\n    let realSize = 0;\n    for (let i = 0; i < count; i++) {\n      realSize += this.store.get('sizes')[i] || this.store.get('originItemSize');\n    }\n    setStore(this.store, {\n      realSize\n    });\n  }\n  setStore(data) {\n    setStore(this.store, data);\n  }\n  drop() {\n    setStore(this.store, initialBase());\n  }\n  setDimensionSize(sizes) {\n    const dimensionData = calculateDimensionData(this.getCurrentState(), sizes);\n    setStore(this.store, dimensionData);\n    return dimensionData;\n  }\n}\nclass DimensionProvider {\n  constructor(viewports) {\n    this.viewports = viewports;\n    this.stores = reduce_1([...rowTypes, ...columnTypes], (sources, k) => {\n      sources[k] = new DimensionStore();\n      return sources;\n    }, {});\n  }\n  setDimensionSize(dimensionType, sizes) {\n    this.stores[dimensionType].setDimensionSize(sizes);\n    this.viewports.stores[dimensionType].setViewPortDimension(sizes);\n  }\n  setRealSize(realCount, type) {\n    this.viewports.stores[type].setViewport({\n      realCount\n    });\n    this.stores[type].setRealSize(realCount);\n  }\n  /**\n   * Sets dimension data and view port coordinate\n   * @param items - data/column items\n   * @param type - dimension type\n   */\n  setData(items, type, noVirtual = false) {\n    this.setRealSize(items.length, type);\n    if (noVirtual) {\n      this.setNoVirtual(type);\n    }\n    this.setViewPortCoordinate({\n      coordinate: this.viewports.stores[type].store.get('lastCoordinate'),\n      type\n    });\n  }\n  setNoVirtual(type) {\n    const dimension = this.stores[type].getCurrentState();\n    this.viewports.stores[type].setViewport({\n      virtualSize: dimension.realSize\n    });\n  }\n  drop() {\n    for (let type of columnTypes) {\n      this.stores[type].drop();\n    }\n  }\n  setColumns(type, sizes, noVirtual = false) {\n    this.stores[type].setDimensionSize(sizes);\n    if (noVirtual) {\n      this.setNoVirtual(type);\n    }\n    this.setViewPortCoordinate({\n      coordinate: this.viewports.stores[type].store.get('lastCoordinate'),\n      type\n    });\n  }\n  setViewPortCoordinate({\n    coordinate,\n    type\n  }) {\n    const dimension = this.stores[type].getCurrentState();\n    this.viewports.stores[type].setViewPortCoordinate(coordinate, dimension);\n  }\n  getViewPortPos(e) {\n    const dimension = this.stores[e.dimension].getCurrentState();\n    const item = getItemByIndex(dimension, e.coordinate);\n    return item.start;\n  }\n  setSettings(data, dimensionType) {\n    let stores = [];\n    switch (dimensionType) {\n      case 'rgCol':\n        stores = columnTypes;\n        break;\n      case 'rgRow':\n        stores = rowTypes;\n        break;\n    }\n    for (let s of stores) {\n      this.stores[s].setStore(data);\n    }\n  }\n}\nclass ViewportProvider {\n  constructor() {\n    this.stores = reduce_1([...rowTypes, ...columnTypes], (sources, k) => {\n      sources[k] = new ViewportStore();\n      return sources;\n    }, {});\n  }\n  setViewport(dimensionType, data) {\n    this.stores[dimensionType].setViewport(data);\n  }\n}\n\n/**\n * Plugin module for revo-grid grid system\n * Add support for automatic column resize\n */\nconst LETTER_BLOCK_SIZE = 7;\nvar ColumnAutoSizeMode;\n(function (ColumnAutoSizeMode) {\n  // increases column width on header click according the largest text value\n  ColumnAutoSizeMode[\"headerClickAutosize\"] = \"headerClickAutoSize\";\n  // increases column width on data set and text edit, decreases performance\n  ColumnAutoSizeMode[\"autoSizeOnTextOverlap\"] = \"autoSizeOnTextOverlap\";\n  // increases and decreases column width based on all items sizes, worst for performance\n  ColumnAutoSizeMode[\"autoSizeAll\"] = \"autoSizeAll\";\n})(ColumnAutoSizeMode || (ColumnAutoSizeMode = {}));\nclass AutoSizeColumn extends BasePlugin {\n  constructor(revogrid, providers, config) {\n    super(revogrid);\n    this.providers = providers;\n    this.config = config;\n    this.autoSizeColumns = null;\n    /** for edge case when no columns defined before data */\n    this.dataResolve = null;\n    this.dataReject = null;\n    this.letterBlockSize = (config === null || config === void 0 ? void 0 : config.letterBlockSize) || LETTER_BLOCK_SIZE;\n    // create test container to check text width\n    if (config === null || config === void 0 ? void 0 : config.preciseSize) {\n      this.precsizeCalculationArea = this.initiatePresizeElement();\n      revogrid.appendChild(this.precsizeCalculationArea);\n    }\n    const aftersourceset = ({\n      detail: {\n        source\n      }\n    }) => {\n      this.setSource(source);\n    };\n    const afteredit = ({\n      detail\n    }) => {\n      this.afteredit(detail);\n    };\n    const afterEditAll = ({\n      detail\n    }) => {\n      this.afterEditAll(detail);\n    };\n    const beforecolumnsset = ({\n      detail: {\n        columns\n      }\n    }) => {\n      this.columnSet(columns);\n    };\n    const headerDblClick = ({\n      detail\n    }) => {\n      const type = ColumnDataProvider.getColumnType(detail);\n      const size = this.getColumnSize(detail.index, type);\n      if (size) {\n        this.providers.dimensionProvider.setDimensionSize(type, {\n          [detail.index]: size\n        });\n      }\n    };\n    this.addEventListener('beforecolumnsset', beforecolumnsset);\n    switch (config === null || config === void 0 ? void 0 : config.mode) {\n      case ColumnAutoSizeMode.autoSizeOnTextOverlap:\n        this.addEventListener('aftersourceset', aftersourceset);\n        this.addEventListener('afteredit', afteredit);\n        break;\n      case ColumnAutoSizeMode.autoSizeAll:\n        this.addEventListener('aftersourceset', aftersourceset);\n        this.addEventListener('afteredit', afterEditAll);\n        break;\n      default:\n        this.addEventListener('headerdblClick', headerDblClick);\n        break;\n    }\n  }\n  async setSource(source) {\n    let autoSize = this.autoSizeColumns;\n    if (this.dataReject) {\n      this.dataReject();\n      this.clearPromise();\n    }\n    /** If data set first and no column provided await until get one */\n    if (!autoSize) {\n      const request = new Promise((resolve, reject) => {\n        this.dataResolve = resolve;\n        this.dataReject = reject;\n      });\n      try {\n        autoSize = await request;\n      } catch (e) {\n        return;\n      }\n    }\n    // calculate sizes\n    each(autoSize, (_v, type) => {\n      const sizes = {};\n      each(autoSize[type], rgCol => {\n        // calculate size\n        rgCol.size = sizes[rgCol.index] = source.reduce((prev, rgRow) => Math.max(prev, this.getLength(rgRow[rgCol.prop])), this.getLength(rgCol.name || ''));\n      });\n      this.providers.dimensionProvider.setDimensionSize(type, sizes);\n    });\n  }\n  getLength(len) {\n    var _a;\n    const padding = 15;\n    if (!len) {\n      return 0;\n    }\n    try {\n      const str = len.toString();\n      /**if exact calculation required proxy with html element, slow operation */\n      if ((_a = this.config) === null || _a === void 0 ? void 0 : _a.preciseSize) {\n        this.precsizeCalculationArea.innerText = str;\n        return this.precsizeCalculationArea.scrollWidth + padding * 2;\n      }\n      return str.length * this.letterBlockSize + padding * 2;\n    } catch (e) {\n      return 0;\n    }\n  }\n  afteredit(e) {\n    let data;\n    if (this.isRangeEdit(e)) {\n      data = e.data;\n    } else {\n      data = {\n        0: {\n          [e.prop]: e.val\n        }\n      };\n    }\n    each(this.autoSizeColumns, (columns, type) => {\n      const sizes = {};\n      each(columns, rgCol => {\n        // calculate size\n        const size = reduce_1(data, (prev, rgRow) => {\n          if (typeof rgRow[rgCol.prop] === 'undefined') {\n            return prev;\n          }\n          return Math.max(prev || 0, this.getLength(rgRow[rgCol.prop]));\n        }, undefined);\n        if (size && rgCol.size < size) {\n          rgCol.size = sizes[rgCol.index] = size;\n        }\n      });\n      this.providers.dimensionProvider.setDimensionSize(type, sizes);\n    });\n  }\n  afterEditAll(e) {\n    const props = {};\n    if (this.isRangeEdit(e)) {\n      each(e.data, r => each(r, (_v, p) => props[p] = true));\n    } else {\n      props[e.prop] = true;\n    }\n    each(this.autoSizeColumns, (columns, type) => {\n      const sizes = {};\n      each(columns, rgCol => {\n        if (props[rgCol.prop]) {\n          const size = this.getColumnSize(rgCol.index, type);\n          if (size) {\n            sizes[rgCol.index] = size;\n          }\n        }\n      });\n      this.providers.dimensionProvider.setDimensionSize(type, sizes);\n    });\n  }\n  getColumnSize(index, type) {\n    const rgCol = this.autoSizeColumns[type][index];\n    if (!rgCol) {\n      return 0;\n    }\n    return reduce_1(this.providers.dataProvider.stores, (r, s) => {\n      const perStore = reduce_1(s.store.get('items'), (prev, _row, i) => {\n        const item = getSourceItem(s.store, i);\n        return Math.max(prev || 0, this.getLength(item[rgCol.prop]));\n      }, 0);\n      return Math.max(r, perStore);\n    }, rgCol.size || 0);\n  }\n  columnSet(columns) {\n    var _a;\n    for (let t of columnTypes) {\n      const type = t;\n      const cols = columns[type];\n      for (let i in cols) {\n        if (cols[i].autoSize || ((_a = this.config) === null || _a === void 0 ? void 0 : _a.allColumns)) {\n          if (!this.autoSizeColumns) {\n            this.autoSizeColumns = {};\n          }\n          if (!this.autoSizeColumns[type]) {\n            this.autoSizeColumns[type] = {};\n          }\n          this.autoSizeColumns[type][i] = Object.assign(Object.assign({}, cols[i]), {\n            index: parseInt(i, 10)\n          });\n        }\n      }\n    }\n    if (this.dataResolve) {\n      this.dataResolve(this.autoSizeColumns);\n      this.clearPromise();\n    }\n  }\n  clearPromise() {\n    this.dataResolve = null;\n    this.dataReject = null;\n  }\n  isRangeEdit(e) {\n    return !!e.data;\n  }\n  initiatePresizeElement() {\n    const styleForFontTest = {\n      position: 'absolute',\n      fontSize: '14px',\n      height: '0',\n      width: '0',\n      whiteSpace: 'nowrap',\n      top: '0',\n      overflowX: 'scroll'\n    };\n    const el = document.createElement('div');\n    for (let s in styleForFontTest) {\n      el.style[s] = styleForFontTest[s];\n    }\n    el.classList.add('revo-test-container');\n    return el;\n  }\n  destroy() {\n    var _a;\n    super.destroy();\n    (_a = this.precsizeCalculationArea) === null || _a === void 0 ? void 0 : _a.remove();\n  }\n}\nconst eq = (value, extra) => {\n  if (typeof value === 'undefined' || value === null && !extra) {\n    return true;\n  }\n  if (typeof value !== 'string') {\n    value = JSON.stringify(value);\n  }\n  const filterVal = extra.toString().toLocaleLowerCase();\n  if (filterVal.length === 0) {\n    return true;\n  }\n  return value.toLocaleLowerCase() === filterVal;\n};\nconst notEq = (value, extra) => !eq(value, extra);\nnotEq.extra = 'input';\neq.extra = 'input';\nconst gtThan = function (value, extra) {\n  let conditionValue;\n  if (typeof value === 'number') {\n    conditionValue = parseFloat(extra === null || extra === void 0 ? void 0 : extra.toString());\n    return value > conditionValue;\n  }\n  return false;\n};\ngtThan.extra = 'input';\nconst gtThanEq = function (value, extra) {\n  return eq(value, extra) || gtThan(value, extra);\n};\ngtThanEq.extra = 'input';\nconst lt = function (value, extra) {\n  let conditionValue;\n  if (typeof value === 'number') {\n    conditionValue = parseFloat(extra === null || extra === void 0 ? void 0 : extra.toString());\n    return value < conditionValue;\n  } else {\n    return false;\n  }\n};\nlt.extra = 'input';\nconst lsEq = function (value, extra) {\n  return eq(value, extra) || lt(value, extra);\n};\nlsEq.extra = 'input';\nconst set = value => !(value === '' || value === null || value === void 0);\nconst notSet = value => !set(value);\nconst beginsWith = (value, extra) => {\n  if (!value) {\n    return false;\n  }\n  if (!extra) {\n    return true;\n  }\n  if (typeof value !== 'string') {\n    value = JSON.stringify(value);\n  }\n  if (typeof extra !== 'string') {\n    extra = JSON.stringify(extra);\n  }\n  return value.toLocaleLowerCase().indexOf(extra.toLocaleLowerCase()) === 0;\n};\nbeginsWith.extra = 'input';\nconst contains = (value, extra) => {\n  if (!value) {\n    return false;\n  }\n  if (extra) {\n    if (typeof value !== 'string') {\n      value = JSON.stringify(value);\n    }\n    return value.toLocaleLowerCase().indexOf(extra.toString().toLowerCase()) > -1;\n  }\n  return true;\n};\nconst notContains = (value, extra) => {\n  return !contains(value, extra);\n};\nnotContains.extra = 'input';\ncontains.extra = 'input';\nconst filterNames = {\n  none: 'None',\n  empty: 'Not set',\n  notEmpty: 'Set',\n  eq: 'Equal',\n  notEq: 'Not equal',\n  begins: 'Begins with',\n  contains: 'Contains',\n  notContains: 'Does not contain',\n  eqN: '=',\n  neqN: '!=',\n  gt: '>',\n  gte: '>=',\n  lt: '<',\n  lte: '<='\n};\nconst filterEntities = {\n  none: () => true,\n  empty: notSet,\n  notEmpty: set,\n  eq: eq,\n  notEq: notEq,\n  begins: beginsWith,\n  contains: contains,\n  notContains: notContains,\n  eqN: eq,\n  neqN: notEq,\n  gt: gtThan,\n  gte: gtThanEq,\n  lt: lt,\n  lte: lsEq\n};\nconst filterTypes = {\n  string: ['notEmpty', 'empty', 'eq', 'notEq', 'begins', 'contains', 'notContains'],\n  number: ['notEmpty', 'empty', 'eqN', 'neqN', 'gt', 'gte', 'lt', 'lte']\n};\nconst FILTER_TRIMMED_TYPE = 'filter';\nclass FilterPlugin extends BasePlugin {\n  constructor(revogrid, uiid, config) {\n    var _a;\n    super(revogrid);\n    this.revogrid = revogrid;\n    this.filterCollection = {};\n    this.multiFilterItems = {};\n    this.possibleFilters = Object.assign({}, filterTypes);\n    this.possibleFilterNames = Object.assign({}, filterNames);\n    this.possibleFilterEntities = Object.assign({}, filterEntities);\n    if (config) {\n      this.initConfig(config);\n    }\n    const headerclick = e => this.headerclick(e);\n    const aftersourceset = async () => {\n      const filterCollectionProps = Object.keys(this.filterCollection);\n      if (filterCollectionProps.length > 0) {\n        // handle old way of filtering by reworking FilterCollection to new MultiFilterItem\n        filterCollectionProps.forEach((prop, index) => {\n          if (!this.multiFilterItems[prop]) {\n            this.multiFilterItems[prop] = [{\n              id: index,\n              type: this.filterCollection[prop].type,\n              value: this.filterCollection[prop].value,\n              relation: 'and'\n            }];\n          }\n        });\n      }\n      await this.runFiltering();\n    };\n    this.addEventListener('headerclick', headerclick);\n    this.addEventListener('aftersourceset', aftersourceset);\n    this.revogrid.registerVNode([h(\"revogr-filter-panel\", {\n      uuid: `filter-${uiid}`,\n      filterItems: this.multiFilterItems,\n      filterNames: this.possibleFilterNames,\n      filterEntities: this.possibleFilterEntities,\n      filterCaptions: (_a = config === null || config === void 0 ? void 0 : config.localization) === null || _a === void 0 ? void 0 : _a.captions,\n      onFilterChange: e => this.onFilterChange(e.detail),\n      disableDynamicFiltering: config === null || config === void 0 ? void 0 : config.disableDynamicFiltering,\n      ref: e => this.pop = e\n    })]);\n  }\n  initConfig(config) {\n    if (config.collection) {\n      this.filterCollection = Object.assign({}, config.collection);\n    }\n    if (config.multiFilterItems) {\n      this.multiFilterItems = Object.assign({}, config.multiFilterItems);\n    }\n    if (config.customFilters) {\n      for (let cType in config.customFilters) {\n        const cFilter = config.customFilters[cType];\n        if (!this.possibleFilters[cFilter.columnFilterType]) {\n          this.possibleFilters[cFilter.columnFilterType] = [];\n        }\n        this.possibleFilters[cFilter.columnFilterType].push(cType);\n        this.possibleFilterEntities[cType] = cFilter.func;\n        this.possibleFilterNames[cType] = cFilter.name;\n      }\n    }\n    /**\n     * which filters has to be included/excluded\n     * convinient way to exclude system filters\n     */\n    if (config.include) {\n      const filters = {};\n      for (let t in this.possibleFilters) {\n        // validate filters, if appropriate function present\n        const newTypes = this.possibleFilters[t].filter(f => config.include.indexOf(f) > -1);\n        if (newTypes.length) {\n          filters[t] = newTypes;\n        }\n      }\n      // if any valid filters provided show them\n      if (Object.keys(filters).length > 0) {\n        this.possibleFilters = filters;\n      }\n    }\n    if (config.localization) {\n      if (config.localization.filterNames) {\n        Object.entries(config.localization.filterNames).forEach(([k, v]) => {\n          if (this.possibleFilterNames[k] != void 0) {\n            this.possibleFilterNames[k] = v;\n          }\n        });\n      }\n    }\n  }\n  async headerclick(e) {\n    var _a;\n    const el = (_a = e.detail.originalEvent) === null || _a === void 0 ? void 0 : _a.target;\n    if (!isFilterBtn(el)) {\n      return;\n    }\n    e.preventDefault();\n    // close if same\n    const changes = await this.pop.getChanges();\n    if (changes && (changes === null || changes === void 0 ? void 0 : changes.prop) === e.detail.prop) {\n      this.pop.show();\n      return;\n    }\n    // filter button clicked, open filter dialog\n    const gridPos = this.revogrid.getBoundingClientRect();\n    const buttonPos = el.getBoundingClientRect();\n    const prop = e.detail.prop;\n    this.pop.filterTypes = this.getColumnFilter(e.detail.filter);\n    this.pop.show(Object.assign(Object.assign({}, this.filterCollection[prop]), {\n      x: buttonPos.x - gridPos.x,\n      y: buttonPos.y - gridPos.y + buttonPos.height,\n      prop\n    }));\n  }\n  getColumnFilter(type) {\n    let filterType = 'string';\n    if (!type) {\n      return {\n        [filterType]: this.possibleFilters[filterType]\n      };\n    }\n    // if custom column filter\n    if (this.isValidType(type)) {\n      filterType = type;\n      // if multiple filters applied\n    } else if (typeof type === 'object' && type.length) {\n      return type.reduce((r, multiType) => {\n        if (this.isValidType(multiType)) {\n          r[multiType] = this.possibleFilters[multiType];\n        }\n        return r;\n      }, {});\n    }\n    return {\n      [filterType]: this.possibleFilters[filterType]\n    };\n  }\n  isValidType(type) {\n    return !!(typeof type === 'string' && this.possibleFilters[type]);\n  }\n  // called on internal component change\n  async onFilterChange(filterItems) {\n    this.multiFilterItems = filterItems;\n    this.runFiltering();\n  }\n  /**\n   * Triggers grid filtering\n   */\n  async doFiltering(collection, items, columns, filterItems) {\n    const columnsToUpdate = [];\n    columns.forEach(rgCol => {\n      const column = Object.assign({}, rgCol);\n      const hasFilter = filterItems[column.prop];\n      if (column[FILTER_PROP] && !hasFilter) {\n        delete column[FILTER_PROP];\n        columnsToUpdate.push(column);\n      }\n      if (!column[FILTER_PROP] && hasFilter) {\n        columnsToUpdate.push(column);\n        column[FILTER_PROP] = true;\n      }\n    });\n    const itemsToFilter = this.getRowFilter(items, filterItems);\n    // check is filter event prevented\n    const {\n      defaultPrevented,\n      detail\n    } = this.emit('beforefiltertrimmed', {\n      collection,\n      itemsToFilter,\n      source: items,\n      filterItems\n    });\n    if (defaultPrevented) {\n      return;\n    }\n    // check is trimmed event prevented\n    const isAddedEvent = await this.revogrid.addTrimmed(detail.itemsToFilter, FILTER_TRIMMED_TYPE);\n    if (isAddedEvent.defaultPrevented) {\n      return;\n    }\n    // applies the hasFilter to the columns to show filter icon\n    await this.revogrid.updateColumns(columnsToUpdate);\n    this.emit('afterFilterApply');\n  }\n  async clearFiltering() {\n    this.multiFilterItems = {};\n    await this.runFiltering();\n  }\n  async runFiltering() {\n    const collection = {};\n    // handle old filterCollection to return the first filter only (if any) from multiFilterItems\n    const filterProps = Object.keys(this.multiFilterItems);\n    for (const prop of filterProps) {\n      // check if we have any filter for a column\n      if (this.multiFilterItems[prop].length > 0) {\n        const firstFilterItem = this.multiFilterItems[prop][0];\n        collection[prop] = {\n          filter: filterEntities[firstFilterItem.type],\n          type: firstFilterItem.type,\n          value: firstFilterItem.value\n        };\n      }\n    }\n    this.filterCollection = collection;\n    const {\n      source,\n      columns\n    } = await this.getData();\n    const {\n      defaultPrevented,\n      detail\n    } = this.emit('beforefilterapply', {\n      collection: this.filterCollection,\n      source,\n      columns,\n      filterItems: this.multiFilterItems\n    });\n    if (defaultPrevented) {\n      return;\n    }\n    this.doFiltering(detail.collection, detail.source, detail.columns, detail.filterItems);\n  }\n  async getData() {\n    const source = await this.revogrid.getSource();\n    const columns = await this.revogrid.getColumns();\n    return {\n      source,\n      columns\n    };\n  }\n  getRowFilter(rows, filterItems) {\n    const propKeys = Object.keys(filterItems);\n    const trimmed = {};\n    let propFilterSatisfiedCount = 0;\n    let lastFilterResults = [];\n    // each rows\n    rows.forEach((model, rowIndex) => {\n      // working on all props\n      for (const prop of propKeys) {\n        const propFilters = filterItems[prop];\n        propFilterSatisfiedCount = 0;\n        lastFilterResults = [];\n        // testing each filter for a prop\n        for (const [filterIndex, filterData] of propFilters.entries()) {\n          // the filter LogicFunction based on the type\n          const filter = this.possibleFilterEntities[filterData.type];\n          // THE MAGIC OF FILTERING IS HERE\n          if (filterData.relation === 'or') {\n            lastFilterResults = [];\n            if (filter(model[prop], filterData.value)) {\n              continue;\n            }\n            propFilterSatisfiedCount++;\n          } else {\n            // 'and' relation will need to know the next filter\n            // so we save this current filter to include it in the next filter\n            lastFilterResults.push(!filter(model[prop], filterData.value));\n            // check first if we have a filter on the next index to pair it with this current filter\n            const nextFilterData = propFilters[filterIndex + 1];\n            // stop the sequence if there is no next filter or if the next filter is not an 'and' relation\n            if (!nextFilterData || nextFilterData.relation !== 'and') {\n              // let's just continue since for sure propFilterSatisfiedCount cannot be satisfied\n              if (lastFilterResults.indexOf(true) === -1) {\n                lastFilterResults = [];\n                continue;\n              }\n              // we need to add all of the lastFilterResults since we need to satisfy all\n              propFilterSatisfiedCount += lastFilterResults.length;\n              lastFilterResults = [];\n            }\n          }\n        } // end of propFilters forEach\n        // add to the list of removed/trimmed rows of filter condition is satisfied\n        if (propFilterSatisfiedCount === propFilters.length) trimmed[rowIndex] = true;\n      } // end of for-of propKeys\n    });\n\n    return trimmed;\n  }\n}\n\n/**\n * Gets the size of an ASCII `string`.\n *\n * @private\n * @param {string} string The string inspect.\n * @returns {number} Returns the string size.\n */\nvar asciiSize = _baseProperty('length');\nvar _asciiSize = asciiSize;\n\n/** Used to compose unicode character classes. */\nvar rsAstralRange$1 = '\\\\ud800-\\\\udfff',\n  rsComboMarksRange$1 = '\\\\u0300-\\\\u036f',\n  reComboHalfMarksRange$1 = '\\\\ufe20-\\\\ufe2f',\n  rsComboSymbolsRange$1 = '\\\\u20d0-\\\\u20ff',\n  rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1,\n  rsVarRange$1 = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsZWJ$1 = '\\\\u200d';\n\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\nvar reHasUnicode = RegExp('[' + rsZWJ$1 + rsAstralRange$1 + rsComboRange$1 + rsVarRange$1 + ']');\n\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */\nfunction hasUnicode(string) {\n  return reHasUnicode.test(string);\n}\nvar _hasUnicode = hasUnicode;\n\n/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff',\n  rsComboMarksRange = '\\\\u0300-\\\\u036f',\n  reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n  rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n  rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n  rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsAstral = '[' + rsAstralRange + ']',\n  rsCombo = '[' + rsComboRange + ']',\n  rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n  rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n  rsNonAstral = '[^' + rsAstralRange + ']',\n  rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n  rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n  rsZWJ = '\\\\u200d';\n\n/** Used to compose unicode regexes. */\nvar reOptMod = rsModifier + '?',\n  rsOptVar = '[' + rsVarRange + ']?',\n  rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n  rsSeq = rsOptVar + reOptMod + rsOptJoin,\n  rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\nvar reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n/**\n * Gets the size of a Unicode `string`.\n *\n * @private\n * @param {string} string The string inspect.\n * @returns {number} Returns the string size.\n */\nfunction unicodeSize(string) {\n  var result = reUnicode.lastIndex = 0;\n  while (reUnicode.test(string)) {\n    ++result;\n  }\n  return result;\n}\nvar _unicodeSize = unicodeSize;\n\n/**\n * Gets the number of symbols in `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the string size.\n */\nfunction stringSize(string) {\n  return _hasUnicode(string) ? _unicodeSize(string) : _asciiSize(string);\n}\nvar _stringSize = stringSize;\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n  setTag = '[object Set]';\n\n/**\n * Gets the size of `collection` by returning its length for array-like\n * values or the number of own enumerable string keyed properties for objects.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object|string} collection The collection to inspect.\n * @returns {number} Returns the collection size.\n * @example\n *\n * _.size([1, 2, 3]);\n * // => 3\n *\n * _.size({ 'a': 1, 'b': 2 });\n * // => 2\n *\n * _.size('pebbles');\n * // => 7\n */\nfunction size(collection) {\n  if (collection == null) {\n    return 0;\n  }\n  if (isArrayLike_1(collection)) {\n    return isString_1(collection) ? _stringSize(collection) : collection.length;\n  }\n  var tag = _getTag(collection);\n  if (tag == mapTag || tag == setTag) {\n    return collection.size;\n  }\n  return _baseKeys(collection).length;\n}\nvar size_1 = size;\n\n/**\n * lifecycle\n * 1) @event beforesorting - sorting just started, nothing happened yet\n * 2) @metod updateColumnSorting - column sorting icon applied to grid and column get updated, data still untiuched\n * 3) @event beforesortingapply - before we applied sorting data to data source, you can prevent data apply from here\n * 4) @event afterSortingApply - sorting applied, just finished event\n *\n * If you prevent event it'll not reach farther steps\n */\nclass SortingPlugin extends BasePlugin {\n  constructor(revogrid) {\n    super(revogrid);\n    this.revogrid = revogrid;\n    this.sorting = null;\n    this.sortingFunc = null;\n    const beforesourceset = ({\n      detail\n    }) => {\n      if (this.hasSorting) {\n        // is sorting allowed\n        const event = this.emit('beforesourcesortingapply');\n        // sorting prevented\n        if (event.defaultPrevented) {\n          return;\n        }\n      }\n      const data = this.setData(detail.source, detail.type);\n      if (data) {\n        detail.source = data;\n      }\n    };\n    const aftercolumnsset = async ({\n      detail: {\n        order\n      }\n    }) => {\n      const columns = await this.revogrid.getColumns();\n      const sortingFunc = {};\n      for (let prop in order) {\n        const column = ColumnDataProvider.getColumnByProp(columns, prop);\n        const cmp = (column === null || column === void 0 ? void 0 : column.cellCompare) || this.defaultCellCompare;\n        sortingFunc[prop] = order[prop] == 'desc' ? this.descCellCompare(cmp) : cmp;\n      }\n      this.sort(order, sortingFunc);\n    };\n    const headerclick = async e => {\n      var _a, _b;\n      if (e.defaultPrevented) {\n        return;\n      }\n      if (!e.detail.column.sortable) {\n        return;\n      }\n      this.headerclick(e.detail.column, e.detail.index, (_b = (_a = e.detail) === null || _a === void 0 ? void 0 : _a.originalEvent) === null || _b === void 0 ? void 0 : _b.shiftKey);\n    };\n    this.addEventListener('beforesourceset', beforesourceset);\n    this.addEventListener('aftercolumnsset', aftercolumnsset);\n    this.addEventListener('initialHeaderClick', headerclick);\n  }\n  get hasSorting() {\n    return !!this.sorting;\n  }\n  async headerclick(column, index, additive) {\n    let order = this.getNextOrder(column.order);\n    const beforeEvent = this.emit('beforesorting', {\n      column,\n      order,\n      additive\n    });\n    if (beforeEvent.defaultPrevented) {\n      return;\n    }\n    order = beforeEvent.detail.order;\n    const newCol = await this.revogrid.updateColumnSorting(beforeEvent.detail.column, index, order, additive);\n    // apply sort data\n    const beforeApplyEvent = this.emit('beforesortingapply', {\n      column: newCol,\n      order,\n      additive\n    });\n    if (beforeApplyEvent.defaultPrevented) {\n      return;\n    }\n    order = beforeApplyEvent.detail.order;\n    const cellCmp = (column === null || column === void 0 ? void 0 : column.cellCompare) || this.defaultCellCompare;\n    const cmp = order == 'asc' ? cellCmp : order == 'desc' ? this.descCellCompare(cellCmp) : undefined;\n    if (additive && this.sorting) {\n      const sorting = {};\n      const sortingFunc = {};\n      Object.assign(sorting, this.sorting);\n      Object.assign(sortingFunc, this.sortingFunc);\n      if (column.prop in sorting && size_1(sorting) > 1 && order === undefined) {\n        delete sorting[column.prop];\n        delete sortingFunc[column.prop];\n      } else {\n        sorting[column.prop] = order;\n        sortingFunc[column.prop] = cmp;\n      }\n      this.sort(sorting, sortingFunc);\n    } else {\n      this.sort({\n        [column.prop]: order\n      }, {\n        [column.prop]: cmp\n      });\n    }\n  }\n  setData(data, type) {\n    // sorting available for rgRow type only\n    if (type === 'rgRow' && this.sortingFunc) {\n      return this.sortItems(data, this.sortingFunc);\n    }\n  }\n  /**\n   * Sorting apply, available for rgRow type only\n   * @param sorting - per column sorting\n   * @param data - this.stores['rgRow'].store.get('source')\n   */\n  async sort(sorting, sortingFunc) {\n    if (!size_1(sorting)) {\n      this.sorting = null;\n      this.sortingFunc = null;\n      return;\n    }\n    this.sorting = sorting;\n    this.sortingFunc = sortingFunc;\n    const store = await this.revogrid.getSourceStore();\n    const source = store.get('source');\n    const proxyItems = this.sortIndexByItems([...store.get('proxyItems')], source, this.sortingFunc);\n    setStore(store, {\n      proxyItems,\n      source: [...source]\n    });\n    this.emit('afterSortingApply');\n  }\n  defaultCellCompare(prop, a, b) {\n    var _a, _b;\n    const av = (_a = a[prop]) === null || _a === void 0 ? void 0 : _a.toString().toLowerCase();\n    const bv = (_b = b[prop]) === null || _b === void 0 ? void 0 : _b.toString().toLowerCase();\n    return av == bv ? 0 : av > bv ? 1 : -1;\n  }\n  descCellCompare(cmp) {\n    return (prop, a, b) => {\n      return -1 * cmp(prop, a, b);\n    };\n  }\n  sortIndexByItems(indexes, source, sortingFunc) {\n    // TODO - is there a situation where multiple kvps in the `sorting` object would cause this to break?\n    for (let prop in sortingFunc) {\n      if (typeof sortingFunc[prop] === 'undefined') {\n        // Unsort indexes\n        return [...Array(indexes.length).keys()];\n      }\n    }\n    return indexes.sort((a, b) => {\n      let sorted = 0;\n      for (let prop in sortingFunc) {\n        const cmp = sortingFunc[prop];\n        const itemA = source[a];\n        const itemB = source[b];\n        sorted = cmp(prop, itemA, itemB);\n        if (sorted) {\n          break;\n        }\n      }\n      return sorted;\n    });\n  }\n  sortItems(source, sortingFunc) {\n    return source.sort((a, b) => {\n      let sorted = 0;\n      for (let prop in sortingFunc) {\n        const cmp = sortingFunc[prop];\n        if (!cmp) {\n          continue;\n        }\n        sorted = cmp(prop, a, b);\n        if (sorted) {\n          break;\n        }\n      }\n      return sorted;\n    });\n  }\n  getNextOrder(currentOrder) {\n    switch (currentOrder) {\n      case undefined:\n        return 'asc';\n      case 'asc':\n        return 'desc';\n      case 'desc':\n        return undefined;\n    }\n  }\n}\n\n/**\n * The base implementation of `_.clamp` which doesn't coerce arguments.\n *\n * @private\n * @param {number} number The number to clamp.\n * @param {number} [lower] The lower bound.\n * @param {number} upper The upper bound.\n * @returns {number} Returns the clamped number.\n */\nfunction baseClamp(number, lower, upper) {\n  if (number === number) {\n    if (upper !== undefined) {\n      number = number <= upper ? number : upper;\n    }\n    if (lower !== undefined) {\n      number = number >= lower ? number : lower;\n    }\n  }\n  return number;\n}\nvar _baseClamp = baseClamp;\n\n/** Used as references for the maximum length and index of an array. */\nvar MAX_ARRAY_LENGTH = 4294967295;\n\n/**\n * Converts `value` to an integer suitable for use as the length of an\n * array-like object.\n *\n * **Note:** This method is based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toLength(3.2);\n * // => 3\n *\n * _.toLength(Number.MIN_VALUE);\n * // => 0\n *\n * _.toLength(Infinity);\n * // => 4294967295\n *\n * _.toLength('3.2');\n * // => 3\n */\nfunction toLength(value) {\n  return value ? _baseClamp(toInteger_1(value), 0, MAX_ARRAY_LENGTH) : 0;\n}\nvar toLength_1 = toLength;\n\n/**\n * The base implementation of `_.fill` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to fill.\n * @param {*} value The value to fill `array` with.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns `array`.\n */\nfunction baseFill(array, value, start, end) {\n  var length = array.length;\n  start = toInteger_1(start);\n  if (start < 0) {\n    start = -start > length ? 0 : length + start;\n  }\n  end = end === undefined || end > length ? length : toInteger_1(end);\n  if (end < 0) {\n    end += length;\n  }\n  end = start > end ? 0 : toLength_1(end);\n  while (start < end) {\n    array[start++] = value;\n  }\n  return array;\n}\nvar _baseFill = baseFill;\n\n/**\n * Fills elements of `array` with `value` from `start` up to, but not\n * including, `end`.\n *\n * **Note:** This method mutates `array`.\n *\n * @static\n * @memberOf _\n * @since 3.2.0\n * @category Array\n * @param {Array} array The array to fill.\n * @param {*} value The value to fill `array` with.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns `array`.\n * @example\n *\n * var array = [1, 2, 3];\n *\n * _.fill(array, 'a');\n * console.log(array);\n * // => ['a', 'a', 'a']\n *\n * _.fill(Array(3), 2);\n * // => [2, 2, 2]\n *\n * _.fill([4, 6, 8, 10], '*', 1, 3);\n * // => [4, '*', '*', 10]\n */\nfunction fill(array, value, start, end) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return [];\n  }\n  if (start && typeof start != 'number' && _isIterateeCall(array, value, start)) {\n    start = 0;\n    end = length;\n  }\n  return _baseFill(array, value, start, end);\n}\nvar fill_1 = fill;\nconst INITIAL = {\n  mime: 'text/csv',\n  fileKind: 'csv',\n  // BOM signature\n  bom: true,\n  columnDelimiter: ',',\n  rowDelimiter: '\\r\\n',\n  encoding: ''\n};\n// The ASCII character code 13 is called a Carriage Return or CR.\nconst CARRIAGE_RETURN = String.fromCharCode(13);\n// Chr(13) followed by a Chr(10) that compose a proper CRLF.\nconst LINE_FEED = String.fromCharCode(10);\nconst DOUBLE_QT = String.fromCharCode(34);\nconst NO_BREAK_SPACE = String.fromCharCode(0xfeff);\nconst escapeRegex = new RegExp('\"', 'g');\nclass ExportCsv {\n  constructor(options = {}) {\n    this.options = Object.assign(Object.assign({}, INITIAL), options);\n  }\n  doExport({\n    data,\n    headers,\n    props\n  }) {\n    let result = this.options.bom ? NO_BREAK_SPACE : '';\n    // any header\n    if ((headers === null || headers === void 0 ? void 0 : headers.length) > 0) {\n      headers.forEach(header => {\n        // ignore empty\n        if (!header.length) {\n          return;\n        }\n        result += this.prepareHeader(header, this.options.columnDelimiter);\n        result += this.options.rowDelimiter;\n      });\n    }\n    data.forEach((rgRow, index) => {\n      if (index > 0) {\n        result += this.options.rowDelimiter;\n      }\n      // support grouping\n      if (isGrouping(rgRow)) {\n        result += this.parseCell(getGroupingName(rgRow), this.options.columnDelimiter);\n        return;\n      }\n      result += props.map(p => this.parseCell(rgRow[p], this.options.columnDelimiter)).join(this.options.columnDelimiter);\n    });\n    return result;\n  }\n  prepareHeader(columnHeaders, columnDelimiter) {\n    let result = '';\n    const newColumnHeaders = columnHeaders.map(v => this.parseCell(v, columnDelimiter, true));\n    result += newColumnHeaders.join(columnDelimiter);\n    return result;\n  }\n  parseCell(value, columnDelimiter, force = false) {\n    let escape = value;\n    if (typeof value !== 'string') {\n      escape = JSON.stringify(value);\n    }\n    const toEscape = [CARRIAGE_RETURN, DOUBLE_QT, LINE_FEED, columnDelimiter];\n    if (typeof escape === 'undefined') {\n      return '';\n    }\n    if (escape !== '' && (force || toEscape.some(i => escape.indexOf(i) >= 0))) {\n      return `\"${escape.replace(escapeRegex, '\"\"')}\"`;\n    }\n    return escape;\n  }\n}\nvar ExportTypes;\n(function (ExportTypes) {\n  ExportTypes[\"csv\"] = \"csv\";\n})(ExportTypes || (ExportTypes = {}));\nclass ExportFilePlugin extends BasePlugin {\n  /** Exports string */\n  async exportString(options = {}, t = ExportTypes.csv) {\n    const data = await this.beforeexport();\n    if (!data) {\n      return null;\n    }\n    return this.formatter(t, options).doExport(data);\n  }\n  /** Exports Blob */\n  async exportBlob(options = {}, t = ExportTypes.csv) {\n    return await this.getBlob(this.formatter(t, options));\n  }\n  /** Export file */\n  async exportFile(options = {}, t = ExportTypes.csv) {\n    const formatter = this.formatter(t, options);\n    const blob = await this.getBlob(formatter);\n    // url\n    const URL = window.URL || window.webkitURL;\n    const a = document.createElement('a');\n    const {\n      filename,\n      fileKind\n    } = formatter.options;\n    const name = `${filename}.${fileKind}`;\n    const url = URL.createObjectURL(blob);\n    a.style.display = 'none';\n    a.setAttribute('href', url);\n    a.setAttribute('download', name);\n    this.revogrid.appendChild(a);\n    a.dispatchEvent(new MouseEvent('click'));\n    this.revogrid.removeChild(a);\n    // delay for revoke, correct for some browsers\n    await timeout(120);\n    URL.revokeObjectURL(url);\n  }\n  /** Blob object */\n  async getBlob(formatter) {\n    const type = `${formatter.options.mime};charset=${formatter.options.encoding}`;\n    if (typeof Blob !== 'undefined') {\n      const data = await this.beforeexport();\n      if (!data) {\n        return null;\n      }\n      return new Blob([formatter.doExport(data)], {\n        type\n      });\n    }\n    return null;\n  }\n  // before event\n  async beforeexport() {\n    let data = await this.getData();\n    const event = this.emit('beforeexport', {\n      data\n    });\n    if (event.defaultPrevented) {\n      return null;\n    }\n    return event.detail.data;\n  }\n  async getData() {\n    const data = await this.getSource();\n    const colSource = [];\n    const colPromises = [];\n    columnTypes.forEach((t, i) => {\n      colPromises.push(this.getColPerSource(t).then(s => colSource[i] = s));\n    });\n    await Promise.all(colPromises);\n    const columns = {\n      headers: [],\n      props: []\n    };\n    for (let source of colSource) {\n      source.headers.forEach((h, i) => {\n        if (!columns.headers[i]) {\n          columns.headers[i] = [];\n        }\n        columns.headers[i].push(...h);\n      });\n      columns.props.push(...source.props);\n    }\n    return Object.assign({\n      data\n    }, columns);\n  }\n  async getColPerSource(t) {\n    const store = await this.revogrid.getColumnStore(t);\n    const source = store.get('source');\n    const virtualIndexes = store.get('items');\n    const depth = store.get('groupingDepth');\n    const groups = store.get('groups');\n    const colNames = [];\n    const colProps = [];\n    const visibleItems = virtualIndexes.reduce((r, v, virtualIndex) => {\n      const prop = source[v].prop;\n      colNames.push(source[v].name || '');\n      colProps.push(prop);\n      r[prop] = virtualIndex;\n      return r;\n    }, {});\n    const rows = this.getGroupHeaders(depth, groups, virtualIndexes, visibleItems);\n    rows.push(colNames);\n    return {\n      headers: rows,\n      props: colProps\n    };\n  }\n  getGroupHeaders(depth, groups, items, visibleItems) {\n    const rows = [];\n    const template = fill_1(new Array(items.length), '');\n    for (let d = 0; d < depth; d++) {\n      const rgRow = [...template];\n      rows.push(rgRow);\n      if (!groups[d]) {\n        continue;\n      }\n      const levelGroups = groups[d];\n      // add names of groups\n      levelGroups.forEach(group => {\n        const minIndex = this.findGroupStartIndex(group.ids, visibleItems);\n        if (typeof minIndex === 'number') {\n          rgRow[minIndex] = group.name;\n        }\n      });\n    }\n    return rows;\n  }\n  findGroupStartIndex(ids, visibleItems) {\n    let min;\n    ids.forEach(id => {\n      const current = visibleItems[id];\n      if (typeof current === 'number') {\n        if (typeof min !== 'number' || min > current) {\n          min = current;\n        }\n      }\n    });\n    return min;\n  }\n  async getSource() {\n    const data = [];\n    const promisesData = [];\n    rowTypes.forEach(t => {\n      const dataPart = [];\n      data.push(dataPart);\n      const promise = this.revogrid.getVisibleSource(t).then(d => dataPart.push(...d));\n      promisesData.push(promise);\n    });\n    await Promise.all(promisesData);\n    return data.reduce((r, v) => {\n      r.push(...v);\n      return r;\n    }, []);\n  }\n  // get correct class for future multiple types support\n  formatter(type, options = {}) {\n    switch (type) {\n      case ExportTypes.csv:\n        return new ExportCsv(options);\n      default:\n        throw new Error('Unknown format');\n    }\n  }\n}\n\n// provide collapse data\nfunction doCollapse(pIndex, source) {\n  const model = source[pIndex];\n  const collapseValue = model[PSEUDO_GROUP_ITEM_VALUE];\n  const trimmed = {};\n  let i = pIndex + 1;\n  const total = source.length;\n  while (i < total) {\n    const currentModel = source[i];\n    if (isGrouping(currentModel)) {\n      const currentValue = currentModel[PSEUDO_GROUP_ITEM_VALUE];\n      if (!currentValue.length || !currentValue.startsWith(collapseValue + ',')) {\n        break;\n      }\n      currentModel[GROUP_EXPANDED] = false;\n    }\n    trimmed[i++] = true;\n  }\n  model[GROUP_EXPANDED] = false;\n  return {\n    trimmed\n  };\n}\n/**\n *\n * @param pIndex - physical index\n * @param vIndex - virtual index, need to update item collection\n * @param source - data source\n * @param rowItemsIndexes - rgRow indexes\n */\nfunction doExpand(vIndex, source, rowItemsIndexes) {\n  const physicalIndex = rowItemsIndexes[vIndex];\n  const model = source[physicalIndex];\n  const currentGroup = getParsedGroup(model[PSEUDO_GROUP_ITEM_ID]);\n  const trimmed = {};\n  // no group found\n  if (!currentGroup) {\n    return {\n      trimmed\n    };\n  }\n  const groupItems = [];\n  model[GROUP_EXPANDED] = true;\n  let i = physicalIndex + 1;\n  const total = source.length;\n  let groupLevelOnly = 0;\n  // go through all rows\n  while (i < total) {\n    const currentModel = source[i];\n    const isGroup = isGrouping(currentModel);\n    // group found\n    if (isGroup) {\n      if (!isSameGroup(currentGroup, model, currentModel)) {\n        break;\n      } else if (!groupLevelOnly) {\n        // if get group first it's group only level\n        groupLevelOnly = currentModel[GROUP_DEPTH];\n      }\n    }\n    // level 0 or same depth\n    if (!groupLevelOnly || isGroup && groupLevelOnly === currentModel[GROUP_DEPTH]) {\n      trimmed[i] = false;\n      groupItems.push(i);\n    }\n    i++;\n  }\n  const result = {\n    trimmed\n  };\n  if (groupItems.length) {\n    const items = [...rowItemsIndexes];\n    items.splice(vIndex + 1, 0, ...groupItems);\n    result.items = items;\n  }\n  return result;\n}\nconst TRIMMED_GROUPING = 'grouping';\n/**\n * Prepare trimming updated indexes for grouping\n * @param initiallyTrimed\n * @param firstLevelMap\n * @param secondLevelMap\n */\nfunction processDoubleConversionTrimmed(initiallyTrimed, firstLevelMap, secondLevelMap) {\n  const trimemedOptionsToUpgrade = {};\n  /**\n   * go through all groups except grouping\n   */\n  for (let type in initiallyTrimed) {\n    if (type === TRIMMED_GROUPING) {\n      continue;\n    }\n    const items = initiallyTrimed[type];\n    const newItems = {};\n    for (let initialIndex in items) {\n      /**\n       * if item exists we find it in collection\n       * we support 2 level of conversions\n       */\n      let newConversionIndex = firstLevelMap[initialIndex];\n      if (secondLevelMap) {\n        newConversionIndex = secondLevelMap[newConversionIndex];\n      }\n      /**\n       * if item was trimmed previously\n       * trimming makes sense to apply\n       */\n      if (items[initialIndex]) {\n        newItems[newConversionIndex] = true;\n        /**\n         * If changes present apply changes to new source\n         */\n        if (newConversionIndex !== parseInt(initialIndex, 10)) {\n          trimemedOptionsToUpgrade[type] = newItems;\n        }\n      }\n    }\n  }\n  return trimemedOptionsToUpgrade;\n}\nclass GroupingRowPlugin extends BasePlugin {\n  constructor(revogrid, providers) {\n    super(revogrid);\n    this.revogrid = revogrid;\n    this.providers = providers;\n  }\n  get hasProps() {\n    var _a, _b, _c;\n    return ((_a = this.options) === null || _a === void 0 ? void 0 : _a.props) && ((_c = (_b = this.options) === null || _b === void 0 ? void 0 : _b.props) === null || _c === void 0 ? void 0 : _c.length);\n  }\n  get store() {\n    return this.providers.dataProvider.stores[GROUPING_ROW_TYPE].store;\n  }\n  // proxy for items get\n  get rowItems() {\n    return this.store.get('items');\n  }\n  get trimmed() {\n    return this.store.get('trimmed');\n  }\n  // befoce cell focus\n  onFocus(e) {\n    if (isGrouping(e.detail.model)) {\n      e.preventDefault();\n    }\n  }\n  // expand event triggered\n  onExpand({\n    virtualIndex\n  }) {\n    const {\n      source\n    } = this.getSource();\n    let newTrimmed = this.trimmed[TRIMMED_GROUPING];\n    let i = getPhysical(this.store, virtualIndex);\n    const model = source[i];\n    const prevExpanded = model[GROUP_EXPANDED];\n    if (!prevExpanded) {\n      const {\n        trimmed,\n        items\n      } = doExpand(virtualIndex, source, this.rowItems);\n      newTrimmed = Object.assign(Object.assign({}, newTrimmed), trimmed);\n      if (items) {\n        setItems(this.store, items);\n      }\n    } else {\n      const {\n        trimmed\n      } = doCollapse(i, source);\n      newTrimmed = Object.assign(Object.assign({}, newTrimmed), trimmed);\n      this.revogrid.clearFocus();\n    }\n    this.store.set('source', source);\n    this.revogrid.addTrimmed(newTrimmed, TRIMMED_GROUPING);\n  }\n  // get source based on proxy item collection to preserve rgRow order\n  getSource(withoutGrouping = false) {\n    const source = this.store.get('source');\n    const items = this.store.get('proxyItems');\n    let index = 0;\n    // order important here, expected parent is first, then others\n    return items.reduce((result, i) => {\n      const model = source[i];\n      if (!withoutGrouping) {\n        result.source.push(model);\n        return result;\n      }\n      // grouping filter\n      if (!isGrouping(model)) {\n        result.source.push(model);\n        result.oldNewIndexes[i] = index;\n        index++;\n      } else {\n        if (model[GROUP_EXPANDED]) {\n          result.prevExpanded[model[PSEUDO_GROUP_ITEM_VALUE]] = true;\n        }\n      }\n      return result;\n    }, {\n      source: [],\n      prevExpanded: {},\n      oldNewIndexes: {}\n    });\n  }\n  setColumnGrouping(cols) {\n    // if 0 column as holder\n    if (cols === null || cols === void 0 ? void 0 : cols.length) {\n      cols[0][PSEUDO_GROUP_COLUMN] = true;\n      return true;\n    }\n    return false;\n  }\n  setColumns({\n    columns\n  }) {\n    for (let type of columnTypes) {\n      if (this.setColumnGrouping(columns[type])) {\n        break;\n      }\n    }\n  }\n  // evaluate drag between groups\n  onDrag(e) {\n    const {\n      from,\n      to\n    } = e.detail;\n    const isDown = to - from >= 0;\n    const {\n      source\n    } = this.getSource();\n    const items = this.rowItems;\n    let i = isDown ? from : to;\n    const end = isDown ? to : from;\n    for (; i < end; i++) {\n      const model = source[items[i]];\n      const isGroup = isGrouping(model);\n      if (isGroup) {\n        e.preventDefault();\n        return;\n      }\n    }\n  }\n  beforeTrimmedApply(trimmed, type) {\n    /** Before filter apply remove grouping filtering */\n    if (type === FILTER_TRIMMED_TYPE) {\n      const source = this.store.get('source');\n      for (let index in trimmed) {\n        if (trimmed[index] && isGrouping(source[index])) {\n          trimmed[index] = false;\n        }\n      }\n    }\n  }\n  // subscribe to grid events to process them accordingly\n  subscribe() {\n    /** if grouping present and new data source arrived */\n    this.addEventListener('beforesourceset', ({\n      detail\n    }) => this.onDataSet(detail));\n    this.addEventListener('beforecolumnsset', ({\n      detail\n    }) => this.setColumns(detail));\n    /**\n     * filter applied need to clear grouping and apply again\n     * based on new results can be new grouping\n     */\n    this.addEventListener('beforetrimmed', ({\n      detail: {\n        trimmed,\n        trimmedType\n      }\n    }) => this.beforeTrimmedApply(trimmed, trimmedType));\n    /**\n     * sorting applied need to clear grouping and apply again\n     * based on new results whole grouping order will changed\n     */\n    this.addEventListener('afterSortingApply', () => this.doSourceUpdate(Object.assign({}, this.options)));\n    /**\n     * Apply logic for focus inside of grouping\n     * We can't focus on grouping rows, navigation only inside of groups for now\n     */\n    this.addEventListener('beforecellfocus', e => this.onFocus(e));\n    /**\n     * Prevent rgRow drag outside the group\n     */\n    this.addEventListener('roworderchanged', e => this.onDrag(e));\n    /**\n     * When grouping expand icon was clicked\n     */\n    this.addEventListener(GROUP_EXPAND_EVENT, ({\n      detail\n    }) => this.onExpand(detail));\n  }\n  /**\n   * Starts global source update with group clearing and applying new one\n   * Initiated when need to reapply grouping\n   */\n  doSourceUpdate(options) {\n    var _a;\n    if (!this.hasProps) {\n      return;\n    }\n    /**\n     * Get source without grouping\n     * @param newOldIndexMap - provides us mapping with new indexes vs old indexes, we would use it for trimmed mapping\n     */\n    const {\n      source,\n      prevExpanded,\n      oldNewIndexes\n    } = this.getSource(true);\n    /**\n     * Group again\n     * @param oldNewIndexMap - provides us mapping with new indexes vs old indexes\n     */\n    const {\n      sourceWithGroups,\n      depth,\n      trimmed,\n      oldNewIndexMap,\n      childrenByGroup\n    } = gatherGrouping(source, ((_a = this.options) === null || _a === void 0 ? void 0 : _a.props) || [], Object.assign({\n      prevExpanded\n    }, options));\n    // setup source\n    this.providers.dataProvider.setData(sourceWithGroups, GROUPING_ROW_TYPE, {\n      depth,\n      customRenderer: options === null || options === void 0 ? void 0 : options.groupLabelTemplate\n    }, true);\n    this.updateTrimmed(trimmed, childrenByGroup, oldNewIndexes, oldNewIndexMap);\n  }\n  /**\n   * Apply grouping on data set\n   * Clear grouping from source\n   * If source came from other plugin\n   */\n  onDataSet(data) {\n    var _a;\n    if (!this.hasProps || !(data === null || data === void 0 ? void 0 : data.source) || !data.source.length) {\n      return;\n    }\n    const source = data.source.filter(s => !isGrouping(s));\n    const expanded = this.revogrid.grouping || {};\n    const {\n      sourceWithGroups,\n      depth,\n      trimmed,\n      oldNewIndexMap,\n      childrenByGroup\n    } = gatherGrouping(source, ((_a = this.options) === null || _a === void 0 ? void 0 : _a.props) || [], Object.assign({}, expanded || {}));\n    data.source = sourceWithGroups;\n    this.providers.dataProvider.setGrouping({\n      depth\n    });\n    this.updateTrimmed(trimmed, childrenByGroup, oldNewIndexMap);\n  }\n  // apply grouping\n  setGrouping(options) {\n    // unsubscribe from all events when group applied\n    this.clearSubscriptions();\n    this.options = options;\n    // clear props, no grouping exists\n    if (!options.props || !Object.keys(options.props).length) {\n      this.clearGrouping();\n      return;\n    }\n    // props exist and source inited\n    const {\n      source\n    } = this.getSource();\n    if (source.length) {\n      this.doSourceUpdate(Object.assign({}, options));\n    }\n    // props exist and columns inited\n    for (let t of columnTypes) {\n      if (this.setColumnGrouping(this.providers.columnProvider.getColumns(t))) {\n        this.providers.columnProvider.refreshByType(t);\n        break;\n      }\n    }\n    // if has any grouping subscribe to events again\n    this.subscribe();\n  }\n  // clear grouping\n  clearGrouping() {\n    // clear columns\n    columnTypes.forEach(t => {\n      const cols = this.providers.columnProvider.getColumns(t);\n      let deleted = false;\n      cols.forEach(c => {\n        if (isGroupingColumn(c)) {\n          delete c[PSEUDO_GROUP_COLUMN];\n          deleted = true;\n        }\n      });\n      // if column store had grouping clear and refresh\n      if (deleted) {\n        this.providers.columnProvider.refreshByType(t);\n      }\n    });\n    // clear rows\n    const {\n      source,\n      oldNewIndexes\n    } = this.getSource(true);\n    this.providers.dataProvider.setData(source, GROUPING_ROW_TYPE, undefined, true);\n    this.updateTrimmed(undefined, undefined, oldNewIndexes);\n  }\n  updateTrimmed(trimmedGroup = {}, _childrenByGroup = {}, firstLevelMap, secondLevelMap) {\n    // map previously trimmed data\n    const trimemedOptionsToUpgrade = processDoubleConversionTrimmed(this.trimmed, firstLevelMap, secondLevelMap);\n    for (let type in trimemedOptionsToUpgrade) {\n      this.revogrid.addTrimmed(trimemedOptionsToUpgrade[type], type);\n    }\n    // const emptyGroups = this.filterOutEmptyGroups(trimemedOptionsToUpgrade, childrenByGroup);\n    // setup trimmed data for grouping\n    this.revogrid.addTrimmed(Object.assign({}, trimmedGroup), TRIMMED_GROUPING);\n  }\n}\n\n/**\n * Draw drag\n */\nclass OrdererService {\n  constructor() {\n    this.parentY = 0;\n  }\n  start(parent, {\n    pos,\n    text,\n    event\n  }) {\n    var _a;\n    const {\n      top\n    } = parent.getBoundingClientRect();\n    this.parentY = top;\n    if (this.text) {\n      this.text.innerText = text;\n    }\n    this.move(pos);\n    this.moveTip({\n      x: event.x,\n      y: event.y\n    });\n    (_a = this.el) === null || _a === void 0 ? void 0 : _a.classList.remove('hidden');\n  }\n  end() {\n    var _a;\n    (_a = this.el) === null || _a === void 0 ? void 0 : _a.classList.add('hidden');\n  }\n  move(pos) {\n    this.moveElement(pos.end - this.parentY);\n  }\n  moveTip({\n    x,\n    y\n  }) {\n    if (!this.draggable) {\n      return;\n    }\n    this.draggable.style.left = `${x}px`;\n    this.draggable.style.top = `${y}px`;\n  }\n  moveElement(y) {\n    if (!this.rgRow) {\n      return;\n    }\n    this.rgRow.style.transform = `translateY(${y}px)`;\n  }\n}\nconst OrderRenderer = ({\n  ref\n}) => {\n  const service = new OrdererService();\n  ref(service);\n  return h(\"div\", {\n    class: \"draggable-wrapper hidden\",\n    ref: e => service.el = e\n  }, h(\"div\", {\n    class: \"draggable\",\n    ref: el => service.draggable = el\n  }, h(\"span\", {\n    class: \"revo-alt-icon\"\n  }), h(\"span\", {\n    ref: e => service.text = e\n  })), h(\"div\", {\n    class: \"drag-position\",\n    ref: e => service.rgRow = e\n  }));\n};\nconst RevoViewPort = ({\n  viewports,\n  dimensions,\n  orderRef,\n  nakedClick,\n  registerElement,\n  onScroll\n}, children) => {\n  const viewPortClick = (e, el) => {\n    if (el === e.target) {\n      nakedClick(e);\n    }\n  };\n  let el;\n  return [h(\"div\", {\n    class: \"main-viewport\",\n    ref: e => el = e,\n    onClick: e => viewPortClick(e, el)\n  }, h(\"div\", {\n    class: \"viewports\"\n  }, children, h(\"revogr-scroll-virtual\", {\n    class: \"vertical\",\n    dimension: \"rgRow\",\n    viewportStore: viewports['rgRow'].store,\n    dimensionStore: dimensions['rgRow'].store,\n    ref: el => registerElement(el, 'rowScroll'),\n    onScrollVirtual: e => onScroll(e.detail)\n  }), h(OrderRenderer, {\n    ref: orderRef\n  }))), h(\"revogr-scroll-virtual\", {\n    class: \"horizontal\",\n    dimension: \"rgCol\",\n    viewportStore: viewports['rgCol'].store,\n    dimensionStore: dimensions['rgCol'].store,\n    ref: el => registerElement(el, 'colScroll'),\n    onScrollVirtual: e => onScroll(e.detail)\n  })];\n};\nclass ViewportService {\n  constructor(sv, contentHeight) {\n    var _a, _b;\n    this.sv = sv;\n    this.storesByType = {};\n    this.storesXToType = {};\n    this.storesYToType = {};\n    (_a = this.sv.selectionStoreConnector) === null || _a === void 0 ? void 0 : _a.beforeUpdate();\n    this.columns = this.getViewportColumnData(contentHeight);\n    (_b = this.sv.scrollingService) === null || _b === void 0 ? void 0 : _b.unregister();\n  }\n  onColumnResize(type, e, store) {\n    var _a;\n    (_a = this.sv.dimensionProvider) === null || _a === void 0 ? void 0 : _a.setDimensionSize(type, e.detail);\n    const changedItems = lodash.reduce(e.detail || {}, (r, size, index) => {\n      const item = getSourceItem(store, parseInt(index, 10));\n      if (item) {\n        r[item.prop] = Object.assign(Object.assign({}, item), {\n          size\n        });\n      }\n      return r;\n    }, {});\n    this.sv.resize(changedItems);\n  }\n  /**\n   * Transform data from stores and apply it to different components\n   */\n  getViewportColumnData(contentHeight) {\n    const columns = [];\n    let x = 0; // we increase x only if column present\n    columnTypes.forEach(val => {\n      const colStore = this.sv.columnProvider.stores[val].store;\n      // only columns that have data show\n      if (!colStore.get('items').length) {\n        return;\n      }\n      const column = {\n        colType: val,\n        position: {\n          x,\n          y: 1\n        },\n        contentHeight,\n        fixWidth: val !== 'rgCol',\n        uuid: `${this.sv.uuid}-${x}`,\n        viewports: this.sv.viewportProvider.stores,\n        dimensions: this.sv.dimensionProvider.stores,\n        rowStores: this.sv.dataProvider.stores,\n        colStore,\n        onHeaderresize: e => this.onColumnResize(val, e, colStore)\n      };\n      if (val === 'rgCol') {\n        column.onResizeViewport = e => {\n          var _a;\n          return (_a = this.sv.viewportProvider) === null || _a === void 0 ? void 0 : _a.setViewport(e.detail.dimension, {\n            virtualSize: e.detail.size\n          });\n        };\n      }\n      const colData = this.gatherColumnData(column);\n      const columnSelectionStore = this.registerCol(colData.position.x, val);\n      // render per each column data collections vertically\n      const dataPorts = this.dataViewPort(column).reduce((r, rgRow) => {\n        // register selection store for Segment\n        const segmentSelection = this.registerSegment(rgRow.position);\n        segmentSelection.setLastCell(rgRow.lastCell);\n        // register selection store for Row\n        const rowSelectionStore = this.registerRow(rgRow.position.y, rgRow.type);\n        const rowDef = Object.assign(Object.assign({}, rgRow), {\n          rowSelectionStore,\n          segmentSelectionStore: segmentSelection.store,\n          ref: e => this.sv.selectionStoreConnector.registerSection(e),\n          onSetRange: e => segmentSelection.setRangeArea(e.detail),\n          onSetTempRange: e => segmentSelection.setTempArea(e.detail),\n          onFocusCell: e => {\n            segmentSelection.clearFocus();\n            this.sv.selectionStoreConnector.focus(segmentSelection, e.detail);\n          }\n        });\n        r.push(rowDef);\n        return r;\n      }, []);\n      columns.push(Object.assign(Object.assign({}, colData), {\n        columnSelectionStore,\n        dataPorts\n      }));\n      x++;\n    });\n    return columns;\n  }\n  /** register selection store for Segment */\n  registerSegment(position) {\n    return this.sv.selectionStoreConnector.register(position);\n  }\n  /** register selection store for Row */\n  registerRow(y, type) {\n    // link to position\n    this.storesByType[type] = y;\n    this.storesYToType[y] = type;\n    return this.sv.selectionStoreConnector.registerRow(y).store;\n  }\n  /** register selection store for Column */\n  registerCol(x, type) {\n    // link to position\n    this.storesByType[type] = x;\n    this.storesXToType[x] = type;\n    return this.sv.selectionStoreConnector.registerColumn(x).store;\n  }\n  /** Collect Column data */\n  gatherColumnData(data) {\n    const parent = data.uuid;\n    const realSize = data.dimensions[data.colType].store.get('realSize');\n    const prop = {\n      contentWidth: realSize,\n      class: data.colType,\n      [`${UUID}`]: data.uuid,\n      contentHeight: data.contentHeight,\n      key: data.colType,\n      onResizeViewport: data.onResizeViewport\n    };\n    if (data.fixWidth) {\n      prop.style = {\n        minWidth: `${realSize}px`\n      };\n    }\n    const headerProp = {\n      parent,\n      colData: getVisibleSourceItem(data.colStore),\n      dimensionCol: data.dimensions[data.colType].store,\n      groups: data.colStore.get('groups'),\n      groupingDepth: data.colStore.get('groupingDepth'),\n      onHeaderresize: data.onHeaderresize\n    };\n    return {\n      prop,\n      position: data.position,\n      headerProp,\n      parent,\n      viewportCol: data.viewports[data.colType].store\n    };\n  }\n  /** Collect Row data */\n  dataViewPort(data) {\n    const slots = {\n      rowPinStart: HEADER_SLOT,\n      rgRow: CONTENT_SLOT,\n      rowPinEnd: FOOTER_SLOT\n    };\n    // y position for selection\n    let y = 0;\n    return rowTypes.reduce((r, type) => {\n      // filter out empty sources, we still need to return source to keep slot working\n      const isPresent = data.viewports[type].store.get('realCount') || type === 'rgRow';\n      const rgCol = Object.assign(Object.assign({}, data), {\n        position: Object.assign(Object.assign({}, data.position), {\n          y: isPresent ? y : EMPTY_INDEX\n        })\n      });\n      r.push(this.dataPartition(rgCol, type, slots[type], type !== 'rgRow'));\n      if (isPresent) {\n        y++;\n      }\n      return r;\n    }, []);\n  }\n  dataPartition(data, type, slot, fixed) {\n    return {\n      colData: data.colStore,\n      viewportCol: data.viewports[data.colType].store,\n      viewportRow: data.viewports[type].store,\n      lastCell: getLastCell(data, type),\n      slot,\n      type,\n      canDrag: !fixed,\n      position: data.position,\n      uuid: `${data.uuid}-${data.position.x}-${data.position.y}`,\n      dataStore: data.rowStores[type].store,\n      dimensionCol: data.dimensions[data.colType].store,\n      dimensionRow: data.dimensions[type].store,\n      style: fixed ? {\n        height: `${data.dimensions[type].store.get('realSize')}px`\n      } : undefined\n    };\n  }\n  scrollToCell(cell) {\n    for (let key in cell) {\n      const coordinate = cell[key];\n      this.sv.scrollingService.onScroll({\n        dimension: key === 'x' ? 'rgCol' : 'rgRow',\n        coordinate\n      });\n    }\n  }\n  /**\n   * Clear current grid focus\n   */\n  clearFocused() {\n    this.sv.selectionStoreConnector.clearAll();\n  }\n  clearEdit() {\n    this.sv.selectionStoreConnector.setEdit(false);\n  }\n  getFocused() {\n    const focused = this.sv.selectionStoreConnector.focusedStore;\n    if (!focused) {\n      return null;\n    }\n    const colType = this.storesXToType[focused.position.x];\n    const column = this.sv.columnProvider.getColumn(focused.cell.x, colType);\n    const rowType = this.storesYToType[focused.position.x];\n    const model = this.sv.dataProvider.getModel(focused.cell.x, rowType);\n    return {\n      column,\n      model,\n      cell: focused.cell,\n      colType,\n      rowType\n    };\n  }\n  getSelectedRange() {\n    return this.sv.selectionStoreConnector.selectedRange;\n  }\n  setEdit(rowIndex, colIndex, colType, rowType) {\n    var _a;\n    const stores = this.storesByType;\n    const storeCoordinate = {\n      x: stores[colType],\n      y: stores[rowType]\n    };\n    (_a = this.sv.selectionStoreConnector) === null || _a === void 0 ? void 0 : _a.setEditByCell(storeCoordinate, {\n      x: colIndex,\n      y: rowIndex\n    });\n  }\n}\n\n/**\n * All render based on sections\n * First we render vertical parts - pinned start, data, pinned end\n * Per each column we render data collections: headers, pinned top, center data, pinned bottom\n */\nconst ViewPortSections = ({\n  resize,\n  editors,\n  rowClass,\n  readonly,\n  range,\n  columns,\n  useClipboard,\n  columnFilter,\n  registerElement,\n  onEdit,\n  onScroll\n}) => {\n  const viewPortHtml = [];\n  /** render viewports columns */\n  for (let view of columns) {\n    /** render viewports rows */\n    const dataViews = [h(\"revogr-header\", Object.assign({\n      viewportCol: view.viewportCol\n    }, view.headerProp, {\n      selectionStore: view.columnSelectionStore,\n      slot: HEADER_SLOT,\n      columnFilter: columnFilter,\n      canResize: resize\n    }))];\n    view.dataPorts.forEach((data, j) => {\n      const key = view.prop.key + (j + 1);\n      const dataView = h(\"revogr-overlay-selection\", Object.assign({}, data, {\n        slot: data.slot,\n        selectionStore: data.segmentSelectionStore,\n        editors: editors,\n        readonly: readonly,\n        range: range,\n        useClipboard: useClipboard,\n        onSetEdit: ({\n          detail\n        }) => onEdit(detail)\n      }), h(\"revogr-data\", Object.assign({}, data, {\n        [UUID]: data.uuid\n      }, {\n        key: key,\n        readonly: readonly,\n        range: range,\n        rowClass: rowClass,\n        rowSelectionStore: data.rowSelectionStore,\n        slot: DATA_SLOT\n      })), h(\"revogr-temp-range\", {\n        selectionStore: data.segmentSelectionStore,\n        dimensionRow: data.dimensionRow,\n        dimensionCol: data.dimensionCol\n      }), h(\"revogr-focus\", {\n        colData: data.colData,\n        dataStore: data.dataStore,\n        selectionStore: data.segmentSelectionStore,\n        dimensionRow: data.dimensionRow,\n        dimensionCol: data.dimensionCol\n      }));\n      dataViews.push(dataView);\n    });\n    viewPortHtml.push(h(\"revogr-viewport-scroll\", Object.assign({}, view.prop, {\n      ref: el => registerElement(el, view.prop.key),\n      onScrollViewport: e => onScroll(e.detail, view.prop.key)\n    }), dataViews));\n  }\n  return viewPortHtml;\n};\nclass GridScrollingService {\n  constructor(setViewport) {\n    this.setViewport = setViewport;\n    this.elements = {};\n  }\n  async onScroll(e, key) {\n    let newEvent;\n    for (let elKey in this.elements) {\n      if (this.isPinnedColumn(key) && e.dimension === 'rgCol') {\n        if (elKey === key || !e.delta) {\n          continue;\n        }\n        for (let el of this.elements[elKey]) {\n          el.changeScroll && (newEvent = el.changeScroll(e));\n        }\n      } else if (e.dimension === 'rgCol' && elKey === 'headerRow') {\n        continue;\n      } else {\n        for (let el of this.elements[elKey]) {\n          el.setScroll(e);\n        }\n      }\n    }\n    let event = e;\n    if (newEvent) {\n      event = await newEvent;\n    }\n    this.setViewport(event);\n  }\n  isPinnedColumn(key) {\n    return ['colPinStart', 'colPinEnd'].indexOf(key) > -1;\n  }\n  registerElements(els) {\n    this.elements = els;\n  }\n  /**\n   * Register new element for farther scroll support\n   * @param el - can be null if holder removed\n   * @param key - element key\n   */\n  registerElement(el, key) {\n    if (!this.elements[key]) {\n      this.elements[key] = [];\n    }\n    // new element added\n    if (el) {\n      this.elements[key].push(el);\n    } else if (this.elements[key]) {\n      // element removed\n      delete this.elements[key];\n    }\n  }\n  unregister() {\n    delete this.elements;\n    this.elements = {};\n  }\n}\nclass StretchColumn extends BasePlugin {\n  constructor(revogrid, dimensionProvider) {\n    super(revogrid);\n    this.dimensionProvider = dimensionProvider;\n    this.stretchedColumn = null;\n    this.scrollSize = getScrollbarWidth(document);\n    const beforecolumnapplied = ({\n      detail: {\n        columns\n      }\n    }) => this.applyStretch(columns);\n    this.addEventListener('beforecolumnapplied', beforecolumnapplied);\n  }\n  setScroll({\n    type,\n    hasScroll\n  }) {\n    var _a;\n    if (type === 'rgRow' && this.stretchedColumn && ((_a = this.stretchedColumn) === null || _a === void 0 ? void 0 : _a.initialSize) === this.stretchedColumn.size) {\n      if (hasScroll) {\n        this.stretchedColumn.size -= this.scrollSize;\n        this.apply();\n        this.dropChanges();\n      }\n    }\n  }\n  activateChanges() {\n    const setScroll = ({\n      detail\n    }) => this.setScroll(detail);\n    this.addEventListener('scrollchange', setScroll);\n  }\n  dropChanges() {\n    this.stretchedColumn = null;\n    this.removeEventListener('scrollchange');\n  }\n  apply() {\n    if (!this.stretchedColumn) {\n      return;\n    }\n    const type = 'rgCol';\n    this.dimensionProvider.setDimensionSize(type, {\n      [this.stretchedColumn.index]: this.stretchedColumn.size\n    });\n  }\n  applyStretch(columns) {\n    this.dropChanges();\n    let sizeDifference = this.revogrid.clientWidth - 1;\n    lodash.each(columns, (_c, type) => {\n      const realSize = this.dimensionProvider.stores[type].store.get('realSize');\n      sizeDifference -= realSize;\n    });\n    if (sizeDifference > 0) {\n      // currently plugin accepts last column\n      const index = columns.rgCol.length - 1;\n      const last = columns.rgCol[index];\n      // has column\n      // no auto size applied\n      // size for column shouldn't be defined\n      const colSize = (last === null || last === void 0 ? void 0 : last.size) || this.revogrid.colSize || 0;\n      const size = sizeDifference + colSize - 1;\n      if (last && !last.autoSize && colSize < size) {\n        this.stretchedColumn = {\n          initialSize: size,\n          index,\n          size\n        };\n        this.apply();\n        this.activateChanges();\n      }\n    }\n  }\n}\nfunction isStretchPlugin(plugin) {\n  return !!plugin.applyStretch;\n}\nclass ColumnOrderHandler {\n  constructor() {\n    this.offset = 0;\n  }\n  renderAutoscroll(_, parent) {\n    if (!parent) {\n      return;\n    }\n    this.autoscrollEl = document.createElement('div');\n    this.autoscrollEl.classList.add('drag-auto-scroll-y');\n    parent.appendChild(this.autoscrollEl);\n  }\n  autoscroll(pos, dataContainerSize, direction = 'translateX') {\n    if (!this.autoscrollEl) {\n      return;\n    }\n    const helperOffset = 10;\n    // calculate current y position inside of the grid active holder\n    // 3 - size of element + border\n    const maxScroll = Math.min(pos + helperOffset, dataContainerSize - 3);\n    this.autoscrollEl.style.transform = `${direction}(${maxScroll}px)`;\n    this.autoscrollEl.scrollIntoView({\n      block: 'nearest',\n      inline: 'nearest'\n    });\n  }\n  start(e, {\n    dataEl,\n    gridRect,\n    scrollEl\n  }, dir = 'left') {\n    const scrollContainerRect = scrollEl.getBoundingClientRect();\n    if (scrollContainerRect) {\n      this.offset = scrollContainerRect[dir] - gridRect[dir];\n    }\n    this.renderAutoscroll(e, dataEl);\n  }\n  stop() {\n    var _a;\n    if (this.element) {\n      this.element.hidden = true;\n    }\n    this.offset = 0;\n    (_a = this.autoscrollEl) === null || _a === void 0 ? void 0 : _a.remove();\n    this.autoscrollEl = undefined;\n  }\n  showHandler(pos, size, direction = 'translateX') {\n    if (!this.element) {\n      return;\n    }\n    // do not allow overcross top of the scrollable area, header excluded\n    if (this.offset) {\n      pos = Math.max(pos, this.offset);\n    }\n    // can not be bigger then grid end\n    pos = Math.min(pos, size);\n    this.element.style.transform = `${direction}(${pos}px)`;\n    this.element.hidden = false;\n  }\n  render() {\n    return h(\"div\", {\n      class: \"drag-position-y\",\n      hidden: true,\n      ref: el => this.element = el\n    });\n  }\n}\n\n/**\n * Plugin for column manual move\n */\nconst COLUMN_CLICK = 'column-click';\nconst MOVE = 'column-mouse-move';\nconst DRAG_END = 'column-drag-end';\nconst BEFORE_DRAG_END = 'before-column-drag-end';\n// use this event subscription to drop D&D for particular columns\nconst DRAG_START = 'column-drag-start';\nclass ColumnPlugin extends BasePlugin {\n  constructor(revogrid, providers) {\n    super(revogrid);\n    this.revogrid = revogrid;\n    this.providers = providers;\n    this.moveFunc = debounce_1(e => this.doMove(e), 5);\n    this.staticDragData = null;\n    this.dragData = null;\n    this.localSubscriptions = {};\n    this.orderUi = new ColumnOrderHandler();\n    revogrid.registerVNode([this.orderUi.render()]);\n    /** Register events */\n    this.localSubscriptions['mouseleave'] = {\n      target: document,\n      callback: e => this.onMouseOut(e)\n    };\n    this.localSubscriptions['mouseup'] = {\n      target: document,\n      callback: e => this.onMouseUp(e)\n    };\n    this.localSubscriptions['mousemove'] = {\n      target: document,\n      callback: e => this.move(e)\n    };\n    this.addEventListener(COLUMN_CLICK, ({\n      detail\n    }) => this.dragStart(detail));\n  }\n  dragStart({\n    event,\n    data\n  }) {\n    if (event.defaultPrevented) {\n      return;\n    }\n    const {\n      defaultPrevented\n    } = dispatch(this.revogrid, DRAG_START, data);\n    // check if allowed to drag particulat column\n    if (defaultPrevented) {\n      return;\n    }\n    this.clearOrder();\n    const {\n      mouseleave,\n      mouseup,\n      mousemove\n    } = this.localSubscriptions;\n    mouseleave.target.addEventListener('mouseleave', mouseleave.callback);\n    mouseup.target.addEventListener('mouseup', mouseup.callback);\n    const dataEl = event.target.closest('revogr-header');\n    const scrollEl = event.target.closest('revogr-viewport-scroll');\n    if (!dataEl || !scrollEl) {\n      return;\n    }\n    if (isColGrouping(data)) {\n      return;\n    }\n    const cols = this.getDimension(data.pin || 'rgCol');\n    const gridRect = this.revogrid.getBoundingClientRect();\n    const elRect = dataEl.getBoundingClientRect();\n    const startItem = getItemByPosition(cols, getLeftRelative(event.x, gridRect.left, elRect.left - gridRect.left));\n    this.staticDragData = {\n      startPos: event.x,\n      startItem,\n      data,\n      dataEl,\n      scrollEl,\n      gridEl: this.revogrid,\n      cols\n    };\n    this.dragData = this.getData(this.staticDragData);\n    mousemove.target.addEventListener('mousemove', mousemove.callback);\n    this.orderUi.start(event, Object.assign(Object.assign({}, this.dragData), this.staticDragData));\n  }\n  doMove(e) {\n    if (!this.staticDragData) {\n      return;\n    }\n    const dragData = this.dragData = this.getData(this.staticDragData);\n    if (!dragData) {\n      return;\n    }\n    const start = this.staticDragData.startPos;\n    if (Math.abs(start - e.x) > 10) {\n      const x = getLeftRelative(e.x, this.dragData.gridRect.left, this.dragData.scrollOffset);\n      const rgCol = getItemByPosition(this.staticDragData.cols, x);\n      this.orderUi.autoscroll(x, dragData.elRect.width);\n      this.orderUi.showHandler(rgCol.end + dragData.scrollOffset, dragData.gridRect.width);\n    }\n  }\n  move(e) {\n    dispatch(this.revogrid, MOVE, Object.assign({}, e));\n    // then do move\n    this.moveFunc(e);\n  }\n  onMouseOut(_) {\n    this.clearOrder();\n  }\n  onMouseUp(e) {\n    // apply new positions\n    if (this.dragData) {\n      let relativePos = getLeftRelative(e.x, this.dragData.gridRect.left, this.dragData.scrollOffset);\n      if (relativePos < 0) {\n        relativePos = 0;\n      }\n      const newPosition = getItemByPosition(this.staticDragData.cols, relativePos);\n      const store = this.providers.column.stores[this.dragData.type].store;\n      const items = [...store.get('items')];\n      // prevent position change if needed\n      const {\n        defaultPrevented: stopDrag\n      } = dispatch(this.revogrid, BEFORE_DRAG_END, Object.assign(Object.assign({}, this.staticDragData), {\n        startPosition: this.staticDragData.startItem,\n        newPosition,\n        newItem: store.get('source')[items[this.staticDragData.startItem.itemIndex]]\n      }));\n      if (!stopDrag) {\n        // todo: if move item out of group remove item from group\n        const toMove = items.splice(this.staticDragData.startItem.itemIndex, 1);\n        items.splice(newPosition.itemIndex, 0, ...toMove);\n        store.set('items', items);\n      }\n      dispatch(this.revogrid, DRAG_END, this.dragData);\n    }\n    this.clearOrder();\n  }\n  clearLocalSubscriptions() {\n    each(this.localSubscriptions, ({\n      target,\n      callback\n    }, key) => target.removeEventListener(key, callback));\n  }\n  clearOrder() {\n    this.staticDragData = null;\n    this.dragData = null;\n    this.clearLocalSubscriptions();\n    this.orderUi.stop();\n  }\n  /**\n   * Clearing subscription\n   */\n  clearSubscriptions() {\n    super.clearSubscriptions();\n    this.clearLocalSubscriptions();\n  }\n  getData({\n    gridEl,\n    dataEl,\n    data\n  }) {\n    const gridRect = gridEl.getBoundingClientRect();\n    const elRect = dataEl.getBoundingClientRect();\n    const scrollOffset = elRect.left - gridRect.left;\n    return {\n      elRect,\n      gridRect,\n      type: data.pin || 'rgCol',\n      scrollOffset\n    };\n  }\n  getDimension(type) {\n    return this.providers.dimension.stores[type].getCurrentState();\n  }\n}\nfunction getLeftRelative(absoluteX, gridPos, offset) {\n  return absoluteX - gridPos - offset;\n}\nconst revoGridStyleCss = \".revo-drag-icon{-webkit-mask-image:url(\\\"data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg viewBox='0 0 438 383' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Cg%3E%3Cpath d='M421.875,70.40625 C426.432292,70.40625 430.175781,68.9414062 433.105469,66.0117188 C436.035156,63.0820312 437.5,59.3385417 437.5,54.78125 L437.5,54.78125 L437.5,15.71875 C437.5,11.1614583 436.035156,7.41796875 433.105469,4.48828125 C430.175781,1.55859375 426.432292,0.09375 421.875,0.09375 L421.875,0.09375 L15.625,0.09375 C11.0677083,0.09375 7.32421875,1.55859375 4.39453125,4.48828125 C1.46484375,7.41796875 0,11.1614583 0,15.71875 L0,15.71875 L0,54.78125 C0,59.3385417 1.46484375,63.0820312 4.39453125,66.0117188 C7.32421875,68.9414062 11.0677083,70.40625 15.625,70.40625 L15.625,70.40625 L421.875,70.40625 Z M421.875,226.65625 C426.432292,226.65625 430.175781,225.191406 433.105469,222.261719 C436.035156,219.332031 437.5,215.588542 437.5,211.03125 L437.5,211.03125 L437.5,171.96875 C437.5,167.411458 436.035156,163.667969 433.105469,160.738281 C430.175781,157.808594 426.432292,156.34375 421.875,156.34375 L421.875,156.34375 L15.625,156.34375 C11.0677083,156.34375 7.32421875,157.808594 4.39453125,160.738281 C1.46484375,163.667969 0,167.411458 0,171.96875 L0,171.96875 L0,211.03125 C0,215.588542 1.46484375,219.332031 4.39453125,222.261719 C7.32421875,225.191406 11.0677083,226.65625 15.625,226.65625 L15.625,226.65625 L421.875,226.65625 Z M421.875,382.90625 C426.432292,382.90625 430.175781,381.441406 433.105469,378.511719 C436.035156,375.582031 437.5,371.838542 437.5,367.28125 L437.5,367.28125 L437.5,328.21875 C437.5,323.661458 436.035156,319.917969 433.105469,316.988281 C430.175781,314.058594 426.432292,312.59375 421.875,312.59375 L421.875,312.59375 L15.625,312.59375 C11.0677083,312.59375 7.32421875,314.058594 4.39453125,316.988281 C1.46484375,319.917969 0,323.661458 0,328.21875 L0,328.21875 L0,367.28125 C0,371.838542 1.46484375,375.582031 4.39453125,378.511719 C7.32421875,381.441406 11.0677083,382.90625 15.625,382.90625 L15.625,382.90625 L421.875,382.90625 Z'%3E%3C/path%3E%3C/g%3E%3C/svg%3E\\\");mask-image:url(\\\"data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg viewBox='0 0 438 383' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Cg%3E%3Cpath d='M421.875,70.40625 C426.432292,70.40625 430.175781,68.9414062 433.105469,66.0117188 C436.035156,63.0820312 437.5,59.3385417 437.5,54.78125 L437.5,54.78125 L437.5,15.71875 C437.5,11.1614583 436.035156,7.41796875 433.105469,4.48828125 C430.175781,1.55859375 426.432292,0.09375 421.875,0.09375 L421.875,0.09375 L15.625,0.09375 C11.0677083,0.09375 7.32421875,1.55859375 4.39453125,4.48828125 C1.46484375,7.41796875 0,11.1614583 0,15.71875 L0,15.71875 L0,54.78125 C0,59.3385417 1.46484375,63.0820312 4.39453125,66.0117188 C7.32421875,68.9414062 11.0677083,70.40625 15.625,70.40625 L15.625,70.40625 L421.875,70.40625 Z M421.875,226.65625 C426.432292,226.65625 430.175781,225.191406 433.105469,222.261719 C436.035156,219.332031 437.5,215.588542 437.5,211.03125 L437.5,211.03125 L437.5,171.96875 C437.5,167.411458 436.035156,163.667969 433.105469,160.738281 C430.175781,157.808594 426.432292,156.34375 421.875,156.34375 L421.875,156.34375 L15.625,156.34375 C11.0677083,156.34375 7.32421875,157.808594 4.39453125,160.738281 C1.46484375,163.667969 0,167.411458 0,171.96875 L0,171.96875 L0,211.03125 C0,215.588542 1.46484375,219.332031 4.39453125,222.261719 C7.32421875,225.191406 11.0677083,226.65625 15.625,226.65625 L15.625,226.65625 L421.875,226.65625 Z M421.875,382.90625 C426.432292,382.90625 430.175781,381.441406 433.105469,378.511719 C436.035156,375.582031 437.5,371.838542 437.5,367.28125 L437.5,367.28125 L437.5,328.21875 C437.5,323.661458 436.035156,319.917969 433.105469,316.988281 C430.175781,314.058594 426.432292,312.59375 421.875,312.59375 L421.875,312.59375 L15.625,312.59375 C11.0677083,312.59375 7.32421875,314.058594 4.39453125,316.988281 C1.46484375,319.917969 0,323.661458 0,328.21875 L0,328.21875 L0,367.28125 C0,371.838542 1.46484375,375.582031 4.39453125,378.511719 C7.32421875,381.441406 11.0677083,382.90625 15.625,382.90625 L15.625,382.90625 L421.875,382.90625 Z'%3E%3C/path%3E%3C/g%3E%3C/svg%3E\\\");width:11px;height:7px;background-size:cover;background-repeat:no-repeat}.revo-alt-icon{-webkit-mask-image:url(\\\"data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg viewBox='0 0 384 383' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Cg%3E%3Cpath d='M192.4375,383 C197.424479,383 201.663411,381.254557 205.154297,377.763672 L205.154297,377.763672 L264.25,318.667969 C270.234375,312.683594 271.605794,306.075846 268.364258,298.844727 C265.122721,291.613607 259.51237,287.998047 251.533203,287.998047 L251.533203,287.998047 L213.382812,287.998047 L213.382812,212.445312 L288.935547,212.445312 L288.935547,250.595703 C288.935547,258.57487 292.551107,264.185221 299.782227,267.426758 C307.013346,270.668294 313.621094,269.296875 319.605469,263.3125 L319.605469,263.3125 L378.701172,204.216797 C382.192057,200.725911 383.9375,196.486979 383.9375,191.5 C383.9375,186.513021 382.192057,182.274089 378.701172,178.783203 L378.701172,178.783203 L319.605469,119.6875 C313.621094,114.201823 307.013346,112.955078 299.782227,115.947266 C292.551107,118.939453 288.935547,124.42513 288.935547,132.404297 L288.935547,132.404297 L288.935547,170.554688 L213.382812,170.554688 L213.382812,95.0019531 L251.533203,95.0019531 C259.51237,95.0019531 264.998047,91.3863932 267.990234,84.1552734 C270.982422,76.9241536 269.735677,70.3164062 264.25,64.3320312 L264.25,64.3320312 L205.154297,5.23632812 C201.663411,1.74544271 197.424479,0 192.4375,0 C187.450521,0 183.211589,1.74544271 179.720703,5.23632812 L179.720703,5.23632812 L120.625,64.3320312 C114.640625,70.3164062 113.269206,76.9241536 116.510742,84.1552734 C119.752279,91.3863932 125.36263,95.0019531 133.341797,95.0019531 L133.341797,95.0019531 L171.492188,95.0019531 L171.492188,170.554688 L95.9394531,170.554688 L95.9394531,132.404297 C95.9394531,124.42513 92.3238932,118.814779 85.0927734,115.573242 C77.8616536,112.331706 71.2539062,113.703125 65.2695312,119.6875 L65.2695312,119.6875 L6.17382812,178.783203 C2.68294271,182.274089 0.9375,186.513021 0.9375,191.5 C0.9375,196.486979 2.68294271,200.725911 6.17382812,204.216797 L6.17382812,204.216797 L65.2695312,263.3125 C71.2539062,268.798177 77.8616536,270.044922 85.0927734,267.052734 C92.3238932,264.060547 95.9394531,258.57487 95.9394531,250.595703 L95.9394531,250.595703 L95.9394531,212.445312 L171.492188,212.445312 L171.492188,287.998047 L133.341797,287.998047 C125.36263,287.998047 119.876953,291.613607 116.884766,298.844727 C113.892578,306.075846 115.139323,312.683594 120.625,318.667969 L120.625,318.667969 L179.720703,377.763672 C183.211589,381.254557 187.450521,383 192.4375,383 Z'%3E%3C/path%3E%3C/g%3E%3C/svg%3E\\\");mask-image:url(\\\"data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg viewBox='0 0 384 383' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Cg%3E%3Cpath d='M192.4375,383 C197.424479,383 201.663411,381.254557 205.154297,377.763672 L205.154297,377.763672 L264.25,318.667969 C270.234375,312.683594 271.605794,306.075846 268.364258,298.844727 C265.122721,291.613607 259.51237,287.998047 251.533203,287.998047 L251.533203,287.998047 L213.382812,287.998047 L213.382812,212.445312 L288.935547,212.445312 L288.935547,250.595703 C288.935547,258.57487 292.551107,264.185221 299.782227,267.426758 C307.013346,270.668294 313.621094,269.296875 319.605469,263.3125 L319.605469,263.3125 L378.701172,204.216797 C382.192057,200.725911 383.9375,196.486979 383.9375,191.5 C383.9375,186.513021 382.192057,182.274089 378.701172,178.783203 L378.701172,178.783203 L319.605469,119.6875 C313.621094,114.201823 307.013346,112.955078 299.782227,115.947266 C292.551107,118.939453 288.935547,124.42513 288.935547,132.404297 L288.935547,132.404297 L288.935547,170.554688 L213.382812,170.554688 L213.382812,95.0019531 L251.533203,95.0019531 C259.51237,95.0019531 264.998047,91.3863932 267.990234,84.1552734 C270.982422,76.9241536 269.735677,70.3164062 264.25,64.3320312 L264.25,64.3320312 L205.154297,5.23632812 C201.663411,1.74544271 197.424479,0 192.4375,0 C187.450521,0 183.211589,1.74544271 179.720703,5.23632812 L179.720703,5.23632812 L120.625,64.3320312 C114.640625,70.3164062 113.269206,76.9241536 116.510742,84.1552734 C119.752279,91.3863932 125.36263,95.0019531 133.341797,95.0019531 L133.341797,95.0019531 L171.492188,95.0019531 L171.492188,170.554688 L95.9394531,170.554688 L95.9394531,132.404297 C95.9394531,124.42513 92.3238932,118.814779 85.0927734,115.573242 C77.8616536,112.331706 71.2539062,113.703125 65.2695312,119.6875 L65.2695312,119.6875 L6.17382812,178.783203 C2.68294271,182.274089 0.9375,186.513021 0.9375,191.5 C0.9375,196.486979 2.68294271,200.725911 6.17382812,204.216797 L6.17382812,204.216797 L65.2695312,263.3125 C71.2539062,268.798177 77.8616536,270.044922 85.0927734,267.052734 C92.3238932,264.060547 95.9394531,258.57487 95.9394531,250.595703 L95.9394531,250.595703 L95.9394531,212.445312 L171.492188,212.445312 L171.492188,287.998047 L133.341797,287.998047 C125.36263,287.998047 119.876953,291.613607 116.884766,298.844727 C113.892578,306.075846 115.139323,312.683594 120.625,318.667969 L120.625,318.667969 L179.720703,377.763672 C183.211589,381.254557 187.450521,383 192.4375,383 Z'%3E%3C/path%3E%3C/g%3E%3C/svg%3E\\\");width:11px;height:11px;background-size:cover;background-repeat:no-repeat}.arrow-down{position:absolute;right:5px;top:0}.arrow-down svg{width:8px;margin-top:5px;margin-left:5px;opacity:0.4}.cell-value-wrapper{margin-right:10px;overflow:hidden;text-overflow:ellipsis}.revo-button{position:relative;overflow:hidden;color:#fff;background-color:#6200ee;height:34px;line-height:34px;padding:0 15px;outline:0;border:0;border-radius:7px;box-sizing:border-box;cursor:pointer}.revo-button.green{background-color:#2ee072;border:1px solid #20d565}.revo-button.red{background-color:#E0662E;border:1px solid #d55920}.revo-button:disabled,.revo-button[disabled]{cursor:not-allowed !important;filter:opacity(0.35) !important}.revo-button.light{border:2px solid #cedefa;line-height:32px;background:none;color:#4876ca;box-shadow:none}revo-grid[theme=default]{font-size:12px}revo-grid[theme=default] revogr-header{text-align:center;line-height:30px;background-color:#f8f9fa}revo-grid[theme=default] revogr-header .group-rgRow{box-shadow:none}revo-grid[theme=default] revogr-header .header-rgRow,revo-grid[theme=default] revogr-header .group-rgRow{text-transform:uppercase;font-size:12px;color:#61656a}revo-grid[theme=default] revogr-header .header-rgRow{height:30px;box-shadow:0 -1px 0 0 #c0c0c0 inset}revo-grid[theme=default] revogr-header .rgHeaderCell{box-shadow:-1px 0 0 0 #c0c0c0, -1px 0 0 0 #c0c0c0 inset, 0 -1px 0 0 #c0c0c0, 0 -1px 0 0 #c0c0c0 inset}revo-grid[theme=default] revogr-header .rgHeaderCell.focused-cell{background:rgba(233, 234, 237, 0.5)}revo-grid[theme=default] .rowHeaders{background-color:#f8f9fa}revo-grid[theme=default] .rowHeaders revogr-data .rgCell{color:#61656a;box-shadow:0 -1px 0 0 #c0c0c0 inset, -1px 0 0 0 #c0c0c0 inset}revo-grid[theme=default] .rowHeaders revogr-header{box-shadow:0 -1px 0 0 #c0c0c0 inset, -1px 0 0 0 #c0c0c0 inset}revo-grid[theme=default] revogr-viewport-scroll.colPinStart revogr-data .rgRow .rgCell:last-child{box-shadow:0 -1px 0 0 #e2e3e3 inset, -1px 0 0 0 #c0c0c0 inset}revo-grid[theme=default] revogr-viewport-scroll.colPinStart .footer-wrapper revogr-data .rgRow:first-child .rgCell{box-shadow:0 1px 0 0 #c0c0c0 inset, -1px 0 0 0 #c0c0c0 inset}revo-grid[theme=default] revogr-viewport-scroll.colPinEnd,revo-grid[theme=default] revogr-viewport-scroll.colPinEnd revogr-header{box-shadow:1px 0 0 #c0c0c0 inset}revo-grid[theme=default] .footer-wrapper revogr-data .rgRow:first-child .rgCell{box-shadow:0 1px 0 0 #e2e3e3 inset, -1px 0 0 0 #e2e3e3 inset, 0 -1px 0 0 #e2e3e3 inset}revo-grid[theme=default] revogr-data{text-align:center}revo-grid[theme=default] revogr-data .rgRow{line-height:27px;box-shadow:0 -1px 0 0 #e2e3e3 inset, -1px 0 0 0 #e2e3e3 inset}revo-grid[theme=default] revogr-data .rgRow.focused-rgRow{background-color:rgba(233, 234, 237, 0.5)}revo-grid[theme=default] revogr-data .rgCell{box-shadow:0 -1px 0 0 #e2e3e3 inset, -1px 0 0 0 #e2e3e3 inset}revo-grid[theme=default] revogr-data .rgCell.disabled{background-color:0 -1px 0 0 #e2e3e3 inset, -1px 0 0 0 #e2e3e3 inset}revo-grid[theme=material]{font-family:Nunito, -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto, \\\"Helvetica Neue\\\", Arial, sans-serif, \\\"Apple Color Emoji\\\", \\\"Segoe UI Emoji\\\", \\\"Segoe UI Symbol\\\"}revo-grid[theme=material] revogr-header{line-height:50px;font-weight:600;text-align:left}revo-grid[theme=material] revogr-header .rgHeaderCell{padding:0 15px;text-overflow:ellipsis}revo-grid[theme=material] revogr-header .header-rgRow{height:50px}revo-grid[theme=material] revogr-data{text-align:left}revo-grid[theme=material] revogr-data .rgRow{line-height:42px}revo-grid[theme=material] revogr-data .rgCell{padding:0 15px}revo-grid[theme=material] .viewports{width:100%}revo-grid[theme=material] .rowHeaders{background-color:#f7faff}revo-grid[theme=material] .rowHeaders revogr-data .rgCell{color:#757a82}revo-grid[theme=material] revogr-header .header-rgRow.group{box-shadow:0 -1px 0 0 #f1f1f1 inset}revo-grid[theme=material] revogr-header .header-rgRow:not(.group){box-shadow:0 -1px 0 0 #f1f1f1, 0 -1px 0 0 #f1f1f1 inset}revo-grid[theme=material] revogr-header .rgHeaderCell.sortable:hover{background-color:#f1f1f1}revo-grid[theme=material] revogr-header .rgHeaderCell.focused-cell{background:rgba(233, 234, 237, 0.5)}revo-grid[theme=material] .footer-wrapper revogr-data{box-shadow:0 -1px 0 #f1f1f1}revo-grid[theme=material] revogr-viewport-scroll.colPinStart{box-shadow:-1px 0 0 #f1f1f1 inset}revo-grid[theme=material] revogr-viewport-scroll.colPinEnd{box-shadow:-1px 0 0 #f1f1f1}revo-grid[theme=material] revogr-data .rgRow{box-shadow:0 -1px 0 0 #f1f1f1 inset}revo-grid[theme=material] revogr-data .rgRow.focused-rgRow{background-color:rgba(233, 234, 237, 0.5)}revo-grid[theme=material] revogr-data .rgCell{color:rgba(0, 0, 0, 0.87)}revo-grid[theme=material] revogr-data .rgCell.disabled{background-color:#f7f7f7}revo-grid[theme=material] revogr-data .revo-draggable>.revo-drag-icon{background-color:#d4d4d4}revo-grid[theme=material] revogr-data .revo-draggable:hover>.revo-drag-icon{background-color:black}revo-grid[theme=darkMaterial]{font-family:Nunito, -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto, \\\"Helvetica Neue\\\", Arial, sans-serif, \\\"Apple Color Emoji\\\", \\\"Segoe UI Emoji\\\", \\\"Segoe UI Symbol\\\";color:#d8d8d8}revo-grid[theme=darkMaterial] revogr-header{line-height:50px;font-weight:600;text-align:left}revo-grid[theme=darkMaterial] revogr-header .rgHeaderCell{padding:0 15px;text-overflow:ellipsis}revo-grid[theme=darkMaterial] revogr-header .header-rgRow{height:50px}revo-grid[theme=darkMaterial] revogr-data{text-align:left}revo-grid[theme=darkMaterial] revogr-data .rgRow{line-height:42px}revo-grid[theme=darkMaterial] revogr-data .rgCell{padding:0 15px}revo-grid[theme=darkMaterial] .viewports{width:100%}revo-grid[theme=darkMaterial] .rowHeaders{background-color:rgba(40, 39, 43, 0.8)}revo-grid[theme=darkMaterial] .rowHeaders revogr-data .rgCell{color:rgba(216, 216, 216, 0.8)}revo-grid[theme=darkMaterial] revogr-header .header-rgRow.group{box-shadow:0 -1px 0 0 #404040 inset}revo-grid[theme=darkMaterial] revogr-header .header-rgRow:not(.group){box-shadow:0 -1px 0 0 #404040, 0 -1px 0 0 #404040 inset}revo-grid[theme=darkMaterial] revogr-header .rgHeaderCell.sortable:hover{background-color:rgba(64, 64, 64, 0.5)}revo-grid[theme=darkMaterial] revogr-header .rgHeaderCell.focused-cell{background:rgba(115, 148, 160, 0.15)}revo-grid[theme=darkMaterial] .footer-wrapper revogr-data{box-shadow:0 -1px 0 #404040}revo-grid[theme=darkMaterial] revogr-data .rgCell{color:rgba(216, 216, 216, 0.9)}revo-grid[theme=darkMaterial] revogr-data .rgRow{box-shadow:0 -1px 0 0 #404040 inset}revo-grid[theme=darkMaterial] revogr-data .rgRow.focused-rgRow{background-color:rgba(115, 148, 160, 0.15)}revo-grid[theme=darkMaterial] revogr-data .revo-draggable>.revo-drag-icon{background-color:rgba(216, 216, 216, 0.5)}revo-grid[theme=darkMaterial] revogr-data .revo-draggable:hover>.revo-drag-icon{background-color:rgba(216, 216, 216, 0.7)}revo-grid[theme=darkMaterial] revogr-viewport-scroll.colPinStart{box-shadow:-1px 0 0 #404040 inset}revo-grid[theme=darkMaterial] revogr-viewport-scroll.colPinEnd{box-shadow:-1px 0 0 #404040}revo-grid[theme=darkCompact]{font-family:Nunito, -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto, \\\"Helvetica Neue\\\", Arial, sans-serif, \\\"Apple Color Emoji\\\", \\\"Segoe UI Emoji\\\", \\\"Segoe UI Symbol\\\";color:#d8d8d8}revo-grid[theme=darkCompact] revogr-header{line-height:45px;font-weight:600;text-align:left}revo-grid[theme=darkCompact] revogr-header .rgHeaderCell{padding:0 15px;text-overflow:ellipsis}revo-grid[theme=darkCompact] revogr-header .header-rgRow{height:45px}revo-grid[theme=darkCompact] revogr-data{text-align:left}revo-grid[theme=darkCompact] revogr-data .rgRow{line-height:32px}revo-grid[theme=darkCompact] revogr-data .rgCell{padding:0 15px}revo-grid[theme=darkCompact] .viewports{width:100%}revo-grid[theme=darkCompact] .rowHeaders{background-color:rgba(40, 39, 43, 0.8)}revo-grid[theme=darkCompact] .rowHeaders revogr-data .rgCell{color:rgba(216, 216, 216, 0.8)}revo-grid[theme=darkCompact] revogr-header .header-rgRow.group{box-shadow:0 -1px 0 0 #404040 inset}revo-grid[theme=darkCompact] revogr-header .header-rgRow:not(.group){box-shadow:0 -1px 0 0 #404040, 0 -1px 0 0 #404040 inset}revo-grid[theme=darkCompact] revogr-header .rgHeaderCell.sortable:hover{background-color:rgba(64, 64, 64, 0.5)}revo-grid[theme=darkCompact] revogr-header .rgHeaderCell.focused-cell{background:rgba(115, 148, 160, 0.15)}revo-grid[theme=darkCompact] .footer-wrapper revogr-data{box-shadow:0 -1px 0 #404040}revo-grid[theme=darkCompact] revogr-data .rgCell{color:rgba(216, 216, 216, 0.9)}revo-grid[theme=darkCompact] revogr-data .rgRow{box-shadow:0 -1px 0 0 #404040 inset}revo-grid[theme=darkCompact] revogr-data .rgRow.focused-rgRow{background-color:rgba(115, 148, 160, 0.15)}revo-grid[theme=darkCompact] revogr-data .revo-draggable>.revo-drag-icon{background-color:rgba(216, 216, 216, 0.5)}revo-grid[theme=darkCompact] revogr-data .revo-draggable:hover>.revo-drag-icon{background-color:rgba(216, 216, 216, 0.7)}revo-grid[theme=darkCompact] revogr-viewport-scroll.colPinStart{box-shadow:-1px 0 0 #404040 inset}revo-grid[theme=darkCompact] revogr-viewport-scroll.colPinEnd{box-shadow:-1px 0 0 #404040}revo-grid[theme=compact]{font-family:Nunito, -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto, \\\"Helvetica Neue\\\", Arial, sans-serif, \\\"Apple Color Emoji\\\", \\\"Segoe UI Emoji\\\", \\\"Segoe UI Symbol\\\"}revo-grid[theme=compact] revogr-header{line-height:45px;font-weight:600;text-align:left}revo-grid[theme=compact] revogr-header .rgHeaderCell{padding:0 15px;text-overflow:ellipsis}revo-grid[theme=compact] revogr-header .header-rgRow{height:45px}revo-grid[theme=compact] revogr-data{text-align:left}revo-grid[theme=compact] revogr-data .rgRow{line-height:32px}revo-grid[theme=compact] revogr-data .rgCell{padding:0 15px}revo-grid[theme=compact] .viewports{width:100%}revo-grid[theme=compact] .rowHeaders{background-color:#f7faff}revo-grid[theme=compact] .rowHeaders revogr-data .rgCell{color:#757a82}revo-grid[theme=compact] revogr-header .header-rgRow.group{box-shadow:0 -1px 0 0 #f1f1f1 inset}revo-grid[theme=compact] revogr-header .header-rgRow:not(.group){box-shadow:0 -1px 0 0 #f1f1f1, 0 -1px 0 0 #f1f1f1 inset}revo-grid[theme=compact] revogr-header .rgHeaderCell.sortable:hover{background-color:#f1f1f1}revo-grid[theme=compact] revogr-header .rgHeaderCell.focused-cell{background:rgba(233, 234, 237, 0.5)}revo-grid[theme=compact] .footer-wrapper revogr-data{box-shadow:0 -1px 0 #f1f1f1}revo-grid[theme=compact] revogr-viewport-scroll.colPinStart{box-shadow:-1px 0 0 #f1f1f1 inset}revo-grid[theme=compact] revogr-viewport-scroll.colPinEnd{box-shadow:-1px 0 0 #f1f1f1}revo-grid[theme=compact] revogr-data .rgRow{box-shadow:0 -1px 0 0 #f1f1f1 inset}revo-grid[theme=compact] revogr-data .rgRow.focused-rgRow{background-color:rgba(233, 234, 237, 0.5)}revo-grid[theme=compact] revogr-data .rgCell{color:rgba(0, 0, 0, 0.87)}revo-grid[theme=compact] revogr-data .rgCell.disabled{background-color:#f7f7f7}revo-grid[theme=compact] revogr-data .revo-draggable>.revo-drag-icon{background-color:#d4d4d4}revo-grid[theme=compact] revogr-data .revo-draggable:hover>.revo-drag-icon{background-color:black}revo-grid[theme=compact] revo-dropdown .rv-dr-root{padding:0px 9px}revo-grid{display:block;height:100%;font-family:Helvetica, Arial, Sans-Serif, serif;font-size:14px;position:relative;-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:flex;flex-direction:column;width:100%;height:100%}revo-grid .footer-wrapper,revo-grid .header-wrapper{width:100%}revo-grid .footer-wrapper revogr-data,revo-grid .header-wrapper revogr-data{z-index:3}revo-grid revo-dropdown{width:100%}revo-grid revo-dropdown .rv-dr-root{max-height:100%}revo-grid revo-dropdown.shrink label{opacity:0}revo-grid .viewports{max-height:100%;display:flex;flex-direction:row;align-items:flex-start;max-width:100%}revo-grid .main-viewport{flex-grow:1;height:0;display:flex;flex-direction:row}revo-grid .draggable{position:fixed;height:30px;line-height:30px;background:#fff;border-radius:3px;display:block;z-index:100;margin-top:5px;margin-right:-20px;box-shadow:0 4px 20px 0 rgba(0, 0, 0, 0.15);padding-left:20px;padding-right:5px}revo-grid .draggable.hidden{display:none}revo-grid .draggable .revo-alt-icon{background-color:black;position:absolute;left:5px;top:10px}revo-grid .draggable-wrapper.hidden{display:none}revo-grid .drag-position{position:absolute;left:0;right:0;height:1px;z-index:2;background:gray}revo-grid .drag-position-y{position:absolute;top:0;left:0;bottom:0;width:1px;z-index:2;background:gray}revo-grid .drag-auto-scroll-y{pointer-events:none;position:absolute;left:0;top:0;height:50px;width:1px}revo-grid .clipboard{position:absolute;left:0;top:0}revo-grid revogr-scroll-virtual{position:relative}revo-grid revogr-scroll-virtual.vertical,revo-grid revogr-scroll-virtual.horizontal{z-index:3}\";\nconst RevoGridComponent = /*@__PURE__*/proxyCustomElement(class extends HTMLElement {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.beforeedit = createEvent(this, \"beforeedit\", 7);\n    this.beforerangeedit = createEvent(this, \"beforerangeedit\", 7);\n    this.afteredit = createEvent(this, \"afteredit\", 7);\n    this.beforeautofill = createEvent(this, \"beforeautofill\", 7);\n    this.beforeaange = createEvent(this, \"beforeaange\", 7);\n    this.afterfocus = createEvent(this, \"afterfocus\", 7);\n    this.roworderchanged = createEvent(this, \"roworderchanged\", 7);\n    this.beforesourcesortingapply = createEvent(this, \"beforesourcesortingapply\", 7);\n    this.beforesortingapply = createEvent(this, \"beforesortingapply\", 7);\n    this.beforesorting = createEvent(this, \"beforesorting\", 7);\n    this.rowdragstart = createEvent(this, \"rowdragstart\", 7);\n    this.headerclick = createEvent(this, \"headerclick\", 7);\n    this.beforecellfocus = createEvent(this, \"beforecellfocus\", 7);\n    this.beforefocuslost = createEvent(this, \"beforefocuslost\", 7);\n    this.beforesourceset = createEvent(this, \"beforesourceset\", 7);\n    this.aftersourceset = createEvent(this, \"aftersourceset\", 7);\n    this.beforecolumnsset = createEvent(this, \"beforecolumnsset\", 7);\n    this.beforecolumnapplied = createEvent(this, \"beforecolumnapplied\", 7);\n    this.aftercolumnsset = createEvent(this, \"aftercolumnsset\", 7);\n    this.beforefilterapply = createEvent(this, \"beforefilterapply\", 7);\n    this.beforefiltertrimmed = createEvent(this, \"beforefiltertrimmed\", 7);\n    this.beforetrimmed = createEvent(this, \"beforetrimmed\", 7);\n    this.aftertrimmed = createEvent(this, \"aftertrimmed\", 7);\n    this.viewportscroll = createEvent(this, \"viewportscroll\", 7);\n    this.beforeexport = createEvent(this, \"beforeexport\", 7);\n    this.beforeeditstart = createEvent(this, \"beforeeditstart\", 7);\n    this.aftercolumnresize = createEvent(this, \"aftercolumnresize\", 7);\n    /**\n     * Defines how many rows/columns should be rendered outside visible area.\n     */\n    this.frameSize = 1;\n    /**\n     * Indicates default rgRow size.\n     * By default 0, means theme package size will be applied\n     */\n    this.rowSize = 0;\n    /** Indicates default column size. */\n    this.colSize = 100;\n    /** When true, user can range selection. */\n    this.range = false;\n    /** When true, grid in read only mode. */\n    this.readonly = false;\n    /** When true, columns are resizable. */\n    this.resize = false;\n    /** When true cell focus appear. */\n    this.canFocus = true;\n    /** When true enable clipboard. */\n    this.useClipboard = true;\n    /**\n     * Columns - defines an array of grid columns.\n     * Can be column or grouped column.\n     */\n    this.columns = [];\n    /**\n     * Source - defines main data source.\n     * Can be an Object or 2 dimensional array([][]);\n     * Keys/indexes referenced from columns Prop\n     */\n    this.source = [];\n    /** Pinned top Source: {[T in ColumnProp]: any} - defines pinned top rows data source. */\n    this.pinnedTopSource = [];\n    /** Pinned bottom Source: {[T in ColumnProp]: any} - defines pinned bottom rows data source. */\n    this.pinnedBottomSource = [];\n    /** Row properies applied */\n    this.rowDefinitions = [];\n    /** Custom editors register */\n    this.editors = {};\n    /** Types\n     *  Every type represent multiple column properties\n     *  Types will be merged but can be replaced with column properties\n     */\n    this.columnTypes = {};\n    /** Theme name */\n    this.theme = 'default';\n    /**\n     * Row class property\n     * Define this property in rgRow object and this will be mapped as rgRow class\n     */\n    this.rowClass = '';\n    /**\n     * Autosize config\n     * Enable columns autoSize, for more details check @autoSizeColumn plugin\n     * By default disabled, hence operation is not resource efficient\n     * true to enable with default params (double header separator click for autosize)\n     * or provide config\n     */\n    this.autoSizeColumn = false;\n    /**\n     * Enables filter plugin\n     * Can be boolean\n     * Can be filter collection\n     */\n    this.filter = false;\n    /**\n     * Enables column move plugin\n     * Can be boolean\n     */\n    this.canMoveColumns = false;\n    /**\n     * Trimmed rows\n     * Functionality which allows to hide rows from main data set\n     * @trimmedRows are physical rgRow indexes to hide\n     */\n    this.trimmedRows = {};\n    /**\n     * Enables export plugin\n     * Can be boolean\n     * Can be export options\n     */\n    this.exporting = false;\n    /**\n     * Defines stretch strategy for columns with @StretchColumn plugin\n     * if there are more space on the right last column size would be increased\n     */\n    this.stretch = true;\n    // --------------------------------------------------------------------------\n    //\n    //  Private Properties\n    //\n    // --------------------------------------------------------------------------\n    // for internal plugin usage\n    this.extraElements = [];\n    this.uuid = null;\n    this.viewport = null;\n    /**\n     * Plugins\n     * Define plugins collection\n     */\n    this.internalPlugins = [];\n    this.subscribers = {};\n  }\n  // --------------------------------------------------------------------------\n  //\n  //  Methods\n  //\n  // --------------------------------------------------------------------------\n  /**\n   * Refreshes data viewport.\n   * Can be specific part as rgRow or pinned rgRow or 'all' by default.\n   */\n  async refresh(type = 'all') {\n    this.dataProvider.refresh(type);\n  }\n  /**  Scrolls view port to specified rgRow index */\n  async scrollToRow(coordinate = 0) {\n    const y = this.dimensionProvider.getViewPortPos({\n      coordinate,\n      dimension: 'rgRow'\n    });\n    await this.scrollToCoordinate({\n      y\n    });\n  }\n  /** Scrolls view port to specified column index */\n  async scrollToColumnIndex(coordinate = 0) {\n    const x = this.dimensionProvider.getViewPortPos({\n      coordinate,\n      dimension: 'rgCol'\n    });\n    await this.scrollToCoordinate({\n      x\n    });\n  }\n  /**  Scrolls view port to specified column prop */\n  async scrollToColumnProp(prop) {\n    const coordinate = this.columnProvider.getColumnIndexByProp(prop, 'rgCol');\n    if (coordinate < 0) {\n      // already on the screen\n      return;\n    }\n    const x = this.dimensionProvider.getViewPortPos({\n      coordinate,\n      dimension: 'rgCol'\n    });\n    await this.scrollToCoordinate({\n      x\n    });\n  }\n  /** Update columns */\n  async updateColumns(cols) {\n    this.columnProvider.updateColumns(cols);\n  }\n  /** Add trimmed by type */\n  async addTrimmed(trimmed, trimmedType = 'external', type = 'rgRow') {\n    const event = this.beforetrimmed.emit({\n      trimmed,\n      trimmedType,\n      type\n    });\n    if (event.defaultPrevented) {\n      return event;\n    }\n    this.dataProvider.setTrimmed({\n      [trimmedType]: event.detail.trimmed\n    }, type);\n    this.aftertrimmed.emit();\n    return event;\n  }\n  /**  Scrolls view port to coordinate */\n  async scrollToCoordinate(cell) {\n    var _a;\n    (_a = this.viewport) === null || _a === void 0 ? void 0 : _a.scrollToCell(cell);\n  }\n  /**  Bring cell to edit mode */\n  async setCellEdit(rgRow, prop, rowSource = 'rgRow') {\n    var _a;\n    const rgCol = ColumnDataProvider.getColumnByProp(this.columns, prop);\n    if (!rgCol) {\n      return;\n    }\n    await timeout();\n    (_a = this.viewport) === null || _a === void 0 ? void 0 : _a.setEdit(rgRow, this.columnProvider.getColumnIndexByProp(prop, 'rgCol'), rgCol.pin || 'rgCol', rowSource);\n  }\n  /**\n   * Register new virtual node inside of grid\n   * Used for additional items creation such as plugin elements\n   */\n  async registerVNode(elements) {\n    this.extraElements.push(...elements);\n    this.extraElements = [...this.extraElements];\n  }\n  /**  Get data from source */\n  async getSource(type = 'rgRow') {\n    return this.dataProvider.stores[type].store.get('source');\n  }\n  /**\n   * Get data from visible part of source\n   * Trimmed/filtered rows will be excluded\n   * @param type - type of source\n   */\n  async getVisibleSource(type = 'rgRow') {\n    return getVisibleSourceItem(this.dataProvider.stores[type].store);\n  }\n  /**\n   * Provides access to rows internal store observer\n   * Can be used for plugin support\n   * @param type - type of source\n   */\n  async getSourceStore(type = 'rgRow') {\n    return this.dataProvider.stores[type].store;\n  }\n  /**\n   * Provides access to column internal store observer\n   * Can be used for plugin support\n   * @param type - type of column\n   */\n  async getColumnStore(type = 'rgCol') {\n    return this.columnProvider.stores[type].store;\n  }\n  /**\n   * Update column sorting\n   * @param column - full column details to update\n   * @param index - virtual column index\n   * @param order - order to apply\n   */\n  async updateColumnSorting(column, index, order, additive) {\n    return this.columnProvider.updateColumnSorting(column, index, order, additive);\n  }\n  /**\n   * Clears column sorting\n   */\n  async clearSorting() {\n    this.columnProvider.clearSorting();\n  }\n  /**\n   * Receive all columns in data source\n   */\n  async getColumns() {\n    return this.columnProvider.getColumns();\n  }\n  /**\n   * Clear current grid focus\n   */\n  async clearFocus() {\n    var _a;\n    const focused = await this.getFocused();\n    const event = this.beforefocuslost.emit(focused);\n    if (event.defaultPrevented) {\n      return;\n    }\n    this.selectionStoreConnector.clearAll();\n    (_a = this.viewport) === null || _a === void 0 ? void 0 : _a.clearFocused();\n  }\n  /**\n   * Get all active plugins instances\n   */\n  async getPlugins() {\n    return [...this.internalPlugins];\n  }\n  /**\n   * Get the currently focused cell.\n   */\n  async getFocused() {\n    var _a;\n    return (_a = this.viewport) === null || _a === void 0 ? void 0 : _a.getFocused();\n  }\n  /**\n   * Get the currently selected Range.\n   */\n  async getSelectedRange() {\n    var _a;\n    return (_a = this.viewport) === null || _a === void 0 ? void 0 : _a.getSelectedRange();\n  }\n  // --------------------------------------------------------------------------\n  //\n  //  Listeners outside scope\n  //\n  // --------------------------------------------------------------------------\n  /** Clear data which is outside of grid container */\n  handleOutsideClick({\n    target\n  }) {\n    if (!(target === null || target === void 0 ? void 0 : target.closest(`[${UUID}=\"${this.uuid}\"]`))) {\n      this.clearFocus();\n    }\n  }\n  // --------------------------------------------------------------------------\n  //\n  //  Listeners\n  //\n  // --------------------------------------------------------------------------\n  /** DRAG AND DROP */\n  onRowDragStarted(e) {\n    var _a;\n    e.cancelBubble = true;\n    const dragStart = this.rowdragstart.emit(e.detail);\n    if (dragStart.defaultPrevented) {\n      e.preventDefault();\n      return;\n    }\n    (_a = this.orderService) === null || _a === void 0 ? void 0 : _a.start(this.element, Object.assign(Object.assign({}, e.detail), dragStart.detail));\n  }\n  onRowDragEnd() {\n    var _a;\n    (_a = this.orderService) === null || _a === void 0 ? void 0 : _a.end();\n  }\n  onRowDrag({\n    detail\n  }) {\n    var _a;\n    (_a = this.orderService) === null || _a === void 0 ? void 0 : _a.move(detail);\n  }\n  onRowMouseMove(e) {\n    var _a;\n    e.cancelBubble = true;\n    (_a = this.orderService) === null || _a === void 0 ? void 0 : _a.moveTip(e.detail);\n  }\n  async onBeforeEdit(e) {\n    e.cancelBubble = true;\n    const {\n      defaultPrevented,\n      detail\n    } = this.beforeedit.emit(e.detail);\n    await timeout();\n    // apply data\n    if (!defaultPrevented) {\n      this.dataProvider.setCellData(detail);\n      this.afteredit.emit(detail);\n    }\n  }\n  onBeforeRangeEdit(e) {\n    e.cancelBubble = true;\n    const {\n      defaultPrevented\n    } = this.beforerangeedit.emit(e.detail);\n    if (defaultPrevented) {\n      e.preventDefault();\n      return;\n    }\n    this.afteredit.emit(e.detail);\n  }\n  onRangeChanged(e) {\n    e.cancelBubble = true;\n    const beforeaange = this.beforeaange.emit(e.detail);\n    if (beforeaange.defaultPrevented) {\n      e.preventDefault();\n    }\n    const beforeFill = this.beforeautofill.emit(e.detail);\n    if (beforeFill.defaultPrevented) {\n      return;\n    }\n  }\n  onRowDropped(e) {\n    e.cancelBubble = true;\n    const {\n      defaultPrevented\n    } = this.roworderchanged.emit(e.detail);\n    if (defaultPrevented) {\n      e.preventDefault();\n    }\n  }\n  onHeaderClick(e) {\n    const {\n      defaultPrevented\n    } = this.headerclick.emit(Object.assign(Object.assign({}, e.detail.column), {\n      originalEvent: e.detail.originalEvent\n    }));\n    if (defaultPrevented) {\n      e.preventDefault();\n    }\n  }\n  onCellFocus(e) {\n    e.cancelBubble = true;\n    const {\n      defaultPrevented\n    } = this.beforecellfocus.emit(e.detail);\n    if (!this.canFocus || defaultPrevented) {\n      e.preventDefault();\n    }\n  }\n  columnChanged(newVal = []) {\n    this.dimensionProvider.drop();\n    const columnGather = ColumnDataProvider.getColumns(newVal, 0, this.columnTypes);\n    this.beforecolumnsset.emit(columnGather);\n    for (let type of columnTypes) {\n      const items = columnGather.columns[type];\n      this.dimensionProvider.setRealSize(items.length, type);\n      this.dimensionProvider.setColumns(type, ColumnDataProvider.getSizes(items), type !== 'rgCol');\n    }\n    this.beforecolumnapplied.emit(columnGather);\n    const columns = this.columnProvider.setColumns(columnGather);\n    this.aftercolumnsset.emit({\n      columns,\n      order: this.columnProvider.order\n    });\n  }\n  themeChanged(t) {\n    this.themeService.register(t);\n    this.dimensionProvider.setSettings({\n      originItemSize: this.themeService.rowSize,\n      frameOffset: this.frameSize || 0\n    }, 'rgRow');\n    this.dimensionProvider.setSettings({\n      originItemSize: this.colSize,\n      frameOffset: this.frameSize || 0\n    }, 'rgCol');\n  }\n  dataChanged(source = []) {\n    let newSource = [...source];\n    const beforesourceset = this.beforesourceset.emit({\n      type: 'rgRow',\n      source: newSource\n    });\n    newSource = beforesourceset.detail.source;\n    newSource = this.dataProvider.setData(newSource, 'rgRow');\n    this.aftersourceset.emit({\n      type: 'rgRow',\n      source: newSource\n    });\n  }\n  dataBottomChanged(newVal = []) {\n    this.dataProvider.setData(newVal, 'rowPinEnd');\n  }\n  dataTopChanged(newVal = []) {\n    this.dataProvider.setData(newVal, 'rowPinStart');\n  }\n  rowDefChanged(newVal = []) {\n    if (!newVal.length) {\n      return;\n    }\n    const rows = reduce_1(newVal, (r, v) => {\n      if (!r[v.type]) {\n        r[v.type] = {};\n      }\n      if (v.size) {\n        if (!r[v.type].sizes) {\n          r[v.type].sizes = {};\n        }\n        r[v.type].sizes[v.index] = v.size;\n      }\n      return r;\n    }, {});\n    each(rows, (r, k) => {\n      if (r.sizes) {\n        this.dimensionProvider.setDimensionSize(k, r.sizes);\n      }\n    });\n  }\n  trimmedRowsChanged(newVal = {}) {\n    this.addTrimmed(newVal);\n  }\n  groupingChanged(newVal = {}) {\n    let grPlugin;\n    for (let p of this.internalPlugins) {\n      const isGrouping = p;\n      if (isGrouping.setGrouping) {\n        grPlugin = isGrouping;\n        break;\n      }\n    }\n    if (!grPlugin) {\n      return;\n    }\n    grPlugin.setGrouping(newVal || {});\n  }\n  applyStretch(isStretch) {\n    if (isStretch === 'false') {\n      isStretch = false;\n    }\n    let stretch = this.internalPlugins.filter(p => isStretchPlugin(p))[0];\n    if (isStretch) {\n      if (!stretch) {\n        this.internalPlugins.push(new StretchColumn(this.element, this.dimensionProvider));\n      } else {\n        stretch.applyStretch(this.columnProvider.getRawColumns());\n      }\n    } else if (stretch) {\n      const index = this.internalPlugins.indexOf(stretch);\n      this.internalPlugins.splice(index, 1);\n    }\n  }\n  connectedCallback() {\n    this.viewportProvider = new ViewportProvider();\n    this.themeService = new ThemeService({\n      rowSize: this.rowSize\n    });\n    this.dimensionProvider = new DimensionProvider(this.viewportProvider);\n    this.columnProvider = new ColumnDataProvider();\n    this.dataProvider = new DataProvider(this.dimensionProvider);\n    this.uuid = `${new Date().getTime()}-rvgrid`;\n    const pluginData = {\n      data: this.dataProvider,\n      column: this.columnProvider,\n      dimension: this.dimensionProvider,\n      viewport: this.viewportProvider,\n      selection: this.selectionStoreConnector\n    };\n    if (this.autoSizeColumn) {\n      this.internalPlugins.push(new AutoSizeColumn(this.element, {\n        dataProvider: this.dataProvider,\n        columnProvider: this.columnProvider,\n        dimensionProvider: this.dimensionProvider\n      }, typeof this.autoSizeColumn === 'object' ? this.autoSizeColumn : undefined));\n    }\n    if (this.filter) {\n      this.internalPlugins.push(new FilterPlugin(this.element, this.uuid, typeof this.filter === 'object' ? this.filter : undefined));\n    }\n    if (this.exporting) {\n      this.internalPlugins.push(new ExportFilePlugin(this.element));\n    }\n    this.internalPlugins.push(new SortingPlugin(this.element));\n    if (this.plugins) {\n      this.plugins.forEach(p => {\n        this.internalPlugins.push(new p(this.element, pluginData));\n      });\n    }\n    if (this.canMoveColumns) {\n      this.internalPlugins.push(new ColumnPlugin(this.element, pluginData));\n    }\n    this.internalPlugins.push(new GroupingRowPlugin(this.element, {\n      dataProvider: this.dataProvider,\n      columnProvider: this.columnProvider\n    }));\n    this.applyStretch(this.stretch);\n    this.themeChanged(this.theme);\n    this.columnChanged(this.columns);\n    this.dataChanged(this.source);\n    this.dataTopChanged(this.pinnedTopSource);\n    this.dataBottomChanged(this.pinnedBottomSource);\n    this.trimmedRowsChanged(this.trimmedRows);\n    this.rowDefChanged(this.rowDefinitions);\n    this.groupingChanged(this.grouping);\n    this.selectionStoreConnector = new SelectionStoreConnector();\n    this.scrollingService = new GridScrollingService(e => {\n      this.dimensionProvider.setViewPortCoordinate({\n        coordinate: e.coordinate,\n        type: e.dimension\n      });\n      this.viewportscroll.emit(e);\n    });\n    this.subscribers = {\n      'click': this.handleOutsideClick.bind(this)\n    };\n    for (let type in this.subscribers) {\n      document.addEventListener(type, this.subscribers[type]);\n    }\n  }\n  disconnectedCallback() {\n    // destroy plugins on element disconnect\n    each(this.internalPlugins, p => p.destroy());\n    this.internalPlugins = [];\n    // clear events\n    for (let type in this.subscribers) {\n      document.removeEventListener(type, this.subscribers[type]);\n      delete this.subscribers[type];\n    }\n  }\n  render() {\n    const contentHeight = this.dimensionProvider.stores['rgRow'].store.get('realSize');\n    this.viewport = new ViewportService({\n      columnProvider: this.columnProvider,\n      dataProvider: this.dataProvider,\n      dimensionProvider: this.dimensionProvider,\n      viewportProvider: this.viewportProvider,\n      uuid: this.uuid,\n      scrollingService: this.scrollingService,\n      orderService: this.orderService,\n      selectionStoreConnector: this.selectionStoreConnector,\n      resize: c => this.aftercolumnresize.emit(c)\n    }, contentHeight);\n    const views = [];\n    if (this.rowHeaders) {\n      const anyView = this.viewport.columns[0];\n      views.push(h(\"revogr-row-headers\", {\n        height: contentHeight,\n        resize: this.resize,\n        dataPorts: anyView.dataPorts,\n        headerProp: anyView.headerProp,\n        uiid: anyView.prop[UUID],\n        rowHeaderColumn: typeof this.rowHeaders === 'object' ? this.rowHeaders : undefined,\n        onScrollViewport: ({\n          detail: e\n        }) => this.scrollingService.onScroll(e, 'headerRow'),\n        onElementToScroll: ({\n          detail: e\n        }) => this.scrollingService.registerElement(e, 'headerRow')\n      }));\n    }\n    views.push(h(ViewPortSections, {\n      columnFilter: !!this.filter,\n      resize: this.resize,\n      readonly: this.readonly,\n      range: this.range,\n      rowClass: this.rowClass,\n      editors: this.editors,\n      useClipboard: this.useClipboard,\n      columns: this.viewport.columns,\n      onEdit: detail => {\n        const event = this.beforeeditstart.emit(detail);\n        if (!event.defaultPrevented) {\n          this.selectionStoreConnector.setEdit(detail.isCancel ? false : detail.val);\n        }\n      },\n      registerElement: (e, k) => this.scrollingService.registerElement(e, k),\n      onScroll: details => this.scrollingService.onScroll(details)\n    }));\n    return h(Host, Object.assign({}, {\n      [`${UUID}`]: this.uuid\n    }), h(RevoViewPort, {\n      viewports: this.viewportProvider.stores,\n      dimensions: this.dimensionProvider.stores,\n      orderRef: e => this.orderService = e,\n      registerElement: (e, k) => this.scrollingService.registerElement(e, k),\n      nakedClick: () => this.viewport.clearEdit(),\n      onScroll: details => this.scrollingService.onScroll(details)\n    }, views), this.extraElements);\n  }\n  get element() {\n    return this;\n  }\n  static get watchers() {\n    return {\n      \"columns\": [\"columnChanged\"],\n      \"theme\": [\"themeChanged\"],\n      \"source\": [\"dataChanged\"],\n      \"pinnedBottomSource\": [\"dataBottomChanged\"],\n      \"pinnedTopSource\": [\"dataTopChanged\"],\n      \"rowDefinitions\": [\"rowDefChanged\"],\n      \"trimmedRows\": [\"trimmedRowsChanged\"],\n      \"grouping\": [\"groupingChanged\"],\n      \"stretch\": [\"applyStretch\"]\n    };\n  }\n  static get style() {\n    return revoGridStyleCss;\n  }\n}, [0, \"revo-grid\", {\n  \"rowHeaders\": [4, \"row-headers\"],\n  \"frameSize\": [2, \"frame-size\"],\n  \"rowSize\": [2, \"row-size\"],\n  \"colSize\": [2, \"col-size\"],\n  \"range\": [4],\n  \"readonly\": [4],\n  \"resize\": [4],\n  \"canFocus\": [4, \"can-focus\"],\n  \"useClipboard\": [4, \"use-clipboard\"],\n  \"columns\": [16],\n  \"source\": [16],\n  \"pinnedTopSource\": [16],\n  \"pinnedBottomSource\": [16],\n  \"rowDefinitions\": [16],\n  \"editors\": [16],\n  \"plugins\": [16],\n  \"columnTypes\": [16],\n  \"theme\": [1537],\n  \"rowClass\": [513, \"row-class\"],\n  \"autoSizeColumn\": [4, \"auto-size-column\"],\n  \"filter\": [4],\n  \"canMoveColumns\": [4, \"can-move-columns\"],\n  \"trimmedRows\": [16],\n  \"exporting\": [4],\n  \"grouping\": [16],\n  \"stretch\": [8],\n  \"extraElements\": [32],\n  \"refresh\": [64],\n  \"scrollToRow\": [64],\n  \"scrollToColumnIndex\": [64],\n  \"scrollToColumnProp\": [64],\n  \"updateColumns\": [64],\n  \"addTrimmed\": [64],\n  \"scrollToCoordinate\": [64],\n  \"setCellEdit\": [64],\n  \"registerVNode\": [64],\n  \"getSource\": [64],\n  \"getVisibleSource\": [64],\n  \"getSourceStore\": [64],\n  \"getColumnStore\": [64],\n  \"updateColumnSorting\": [64],\n  \"clearSorting\": [64],\n  \"getColumns\": [64],\n  \"clearFocus\": [64],\n  \"getPlugins\": [64],\n  \"getFocused\": [64],\n  \"getSelectedRange\": [64]\n}, [[0, \"internalRowDragStart\", \"onRowDragStarted\"], [0, \"internalRowDragEnd\", \"onRowDragEnd\"], [0, \"internalRowDrag\", \"onRowDrag\"], [0, \"internalRowMouseMove\", \"onRowMouseMove\"], [0, \"internalCellEdit\", \"onBeforeEdit\"], [0, \"internalRangeDataApply\", \"onBeforeRangeEdit\"], [0, \"internalSelectionChanged\", \"onRangeChanged\"], [0, \"initialRowDropped\", \"onRowDropped\"], [0, \"initialHeaderClick\", \"onHeaderClick\"], [0, \"internalFocusCell\", \"onCellFocus\"]]]);\nfunction defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"revo-grid\", \"revogr-data\", \"revogr-edit\", \"revogr-focus\", \"revogr-header\", \"revogr-order-editor\", \"revogr-overlay-selection\", \"revogr-row-headers\", \"revogr-scroll-virtual\", \"revogr-temp-range\", \"revogr-viewport-scroll\"];\n  components.forEach(tagName => {\n    switch (tagName) {\n      case \"revo-grid\":\n        if (!customElements.get(tagName)) {\n          customElements.define(tagName, RevoGridComponent);\n        }\n        break;\n      case \"revogr-data\":\n        if (!customElements.get(tagName)) {\n          defineCustomElement$b();\n        }\n        break;\n      case \"revogr-edit\":\n        if (!customElements.get(tagName)) {\n          defineCustomElement$a();\n        }\n        break;\n      case \"revogr-focus\":\n        if (!customElements.get(tagName)) {\n          defineCustomElement$9();\n        }\n        break;\n      case \"revogr-header\":\n        if (!customElements.get(tagName)) {\n          defineCustomElement$8();\n        }\n        break;\n      case \"revogr-order-editor\":\n        if (!customElements.get(tagName)) {\n          defineCustomElement$7();\n        }\n        break;\n      case \"revogr-overlay-selection\":\n        if (!customElements.get(tagName)) {\n          defineCustomElement$6();\n        }\n        break;\n      case \"revogr-row-headers\":\n        if (!customElements.get(tagName)) {\n          defineCustomElement$5();\n        }\n        break;\n      case \"revogr-scroll-virtual\":\n        if (!customElements.get(tagName)) {\n          defineCustomElement$4();\n        }\n        break;\n      case \"revogr-temp-range\":\n        if (!customElements.get(tagName)) {\n          defineCustomElement$3();\n        }\n        break;\n      case \"revogr-viewport-scroll\":\n        if (!customElements.get(tagName)) {\n          defineCustomElement$2();\n        }\n        break;\n    }\n  });\n}\ndefineCustomElement$1();\nconst RevoGrid = RevoGridComponent;\nconst defineCustomElement = defineCustomElement$1;\nexport { RevoGrid, ThemeService as T, defineCustomElement };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"/*!\n * Built by Revolist\n */\nimport { s as scaleValue } from './utils.js';\nconst initialParams = {\n  contentSize: 0,\n  clientSize: 0,\n  virtualSize: 0,\n  maxSize: 0\n};\nclass LocalScrollService {\n  constructor(cfg) {\n    this.cfg = cfg;\n    this.preventArtificialScroll = {\n      rgRow: null,\n      rgCol: null\n    };\n    // to check if scroll changed\n    this.previousScroll = {\n      rgRow: 0,\n      rgCol: 0\n    };\n    this.params = {\n      rgRow: Object.assign({}, initialParams),\n      rgCol: Object.assign({}, initialParams)\n    };\n  }\n  static getVirtualContentSize(contentSize, clientSize, virtualSize = 0) {\n    return contentSize + (virtualSize ? clientSize - virtualSize : 0);\n  }\n  setParams(params, dimension) {\n    const virtualContentSize = LocalScrollService.getVirtualContentSize(params.contentSize, params.clientSize, params.virtualSize);\n    this.params[dimension] = Object.assign(Object.assign({}, params), {\n      maxSize: virtualContentSize - params.clientSize,\n      virtualContentSize\n    });\n  }\n  // apply scroll values after scroll done\n  setScroll(e) {\n    this.cancelScroll(e.dimension);\n    this.preventArtificialScroll[e.dimension] = window.requestAnimationFrame(() => {\n      const params = this.getParams(e.dimension);\n      e.coordinate = Math.ceil(e.coordinate);\n      this.previousScroll[e.dimension] = this.wrapCoordinate(e.coordinate, params);\n      this.preventArtificialScroll[e.dimension] = null;\n      this.cfg.afterScroll(Object.assign(Object.assign({}, e), {\n        coordinate: params.virtualSize ? this.convert(e.coordinate, params, false) : e.coordinate\n      }));\n    });\n  }\n  // initiate scrolling event\n  scroll(coordinate, dimension, force = false, delta) {\n    this.cancelScroll(dimension);\n    if (!force && this.previousScroll[dimension] === coordinate) {\n      this.previousScroll[dimension] = 0;\n      return;\n    }\n    const param = this.getParams(dimension);\n    this.cfg.beforeScroll({\n      dimension: dimension,\n      coordinate: param.virtualSize ? this.convert(coordinate, param) : coordinate,\n      delta\n    });\n  }\n  getParams(dimension) {\n    return this.params[dimension];\n  }\n  // check if scroll outside of region to avoid looping\n  wrapCoordinate(c, param) {\n    if (c < 0) {\n      return 0;\n    }\n    if (c > param.maxSize) {\n      return param.maxSize;\n    }\n    return c;\n  }\n  // prevent already started scroll, performance optimization\n  cancelScroll(dimension) {\n    if (typeof this.preventArtificialScroll[dimension] === 'number') {\n      window.cancelAnimationFrame(this.preventArtificialScroll[dimension]);\n      this.preventArtificialScroll[dimension] = null;\n      return true;\n    }\n    return false;\n  }\n  /* convert virtual to real and back, scale range */\n  convert(pos, param, toReal = true) {\n    const minRange = param.clientSize;\n    const from = [0, param.virtualContentSize - minRange];\n    const to = [0, param.contentSize - param.virtualSize];\n    if (toReal) {\n      return scaleValue(pos, from, to);\n    }\n    return scaleValue(pos, to, from);\n  }\n}\nexport { LocalScrollService as L };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*!\n * Built by Revolist\n */\nimport { getRenderingRef, forceUpdate } from '@stencil/core/internal/client';\nimport { t as toInteger_1, _ as _baseFindIndex, a as toFinite_1 } from './toInteger.js';\nimport { _ as _baseIteratee, e as eq_1 } from './_baseIteratee.js';\nimport { i as isArrayLike_1, b as _isIndex } from './keys.js';\nimport { b as isObject_1 } from './isSymbol.js';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax$1 = Math.max;\n\n/**\n * This method is like `_.find` except that it returns the index of the first\n * element `predicate` returns truthy for instead of the element itself.\n *\n * @static\n * @memberOf _\n * @since 1.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.findIndex(users, function(o) { return o.user == 'barney'; });\n * // => 0\n *\n * // The `_.matches` iteratee shorthand.\n * _.findIndex(users, { 'user': 'fred', 'active': false });\n * // => 1\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findIndex(users, ['active', false]);\n * // => 0\n *\n * // The `_.property` iteratee shorthand.\n * _.findIndex(users, 'active');\n * // => 2\n */\nfunction findIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger_1(fromIndex);\n  if (index < 0) {\n    index = nativeMax$1(length + index, 0);\n  }\n  return _baseFindIndex(array, _baseIteratee(predicate), index);\n}\nvar findIndex_1 = findIndex;\nconst appendToMap = (map, propName, value) => {\n  const items = map.get(propName);\n  if (!items) {\n    map.set(propName, [value]);\n  } else if (!items.includes(value)) {\n    items.push(value);\n  }\n};\nconst debounce = (fn, ms) => {\n  let timeoutId;\n  return (...args) => {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => {\n      timeoutId = 0;\n      fn(...args);\n    }, ms);\n  };\n};\n\n/**\n * Check if a possible element isConnected.\n * The property might not be there, so we check for it.\n *\n * We want it to return true if isConnected is not a property,\n * otherwise we would remove these elements and would not update.\n *\n * Better leak in Edge than to be useless.\n */\nconst isConnected = maybeElement => !('isConnected' in maybeElement) || maybeElement.isConnected;\nconst cleanupElements = debounce(map => {\n  for (let key of map.keys()) {\n    map.set(key, map.get(key).filter(isConnected));\n  }\n}, 2000);\nconst stencilSubscription = ({\n  on\n}) => {\n  const elmsToUpdate = new Map();\n  if (typeof getRenderingRef === 'function') {\n    // If we are not in a stencil project, we do nothing.\n    // This function is not really exported by @stencil/core.\n    on('dispose', () => {\n      elmsToUpdate.clear();\n    });\n    on('get', propName => {\n      const elm = getRenderingRef();\n      if (elm) {\n        appendToMap(elmsToUpdate, propName, elm);\n      }\n    });\n    on('set', propName => {\n      const elements = elmsToUpdate.get(propName);\n      if (elements) {\n        elmsToUpdate.set(propName, elements.filter(forceUpdate));\n      }\n      cleanupElements(elmsToUpdate);\n    });\n    on('reset', () => {\n      elmsToUpdate.forEach(elms => elms.forEach(forceUpdate));\n      cleanupElements(elmsToUpdate);\n    });\n  }\n};\nconst createObservableMap = (defaultState, shouldUpdate = (a, b) => a !== b) => {\n  let states = new Map(Object.entries(defaultState !== null && defaultState !== void 0 ? defaultState : {}));\n  const handlers = {\n    dispose: [],\n    get: [],\n    set: [],\n    reset: []\n  };\n  const reset = () => {\n    states = new Map(Object.entries(defaultState !== null && defaultState !== void 0 ? defaultState : {}));\n    handlers.reset.forEach(cb => cb());\n  };\n  const dispose = () => {\n    // Call first dispose as resetting the state would\n    // cause less updates ;)\n    handlers.dispose.forEach(cb => cb());\n    reset();\n  };\n  const get = propName => {\n    handlers.get.forEach(cb => cb(propName));\n    return states.get(propName);\n  };\n  const set = (propName, value) => {\n    const oldValue = states.get(propName);\n    if (shouldUpdate(value, oldValue, propName)) {\n      states.set(propName, value);\n      handlers.set.forEach(cb => cb(propName, value, oldValue));\n    }\n  };\n  const state = typeof Proxy === 'undefined' ? {} : new Proxy(defaultState, {\n    get(_, propName) {\n      return get(propName);\n    },\n    ownKeys(_) {\n      return Array.from(states.keys());\n    },\n    getOwnPropertyDescriptor() {\n      return {\n        enumerable: true,\n        configurable: true\n      };\n    },\n    has(_, propName) {\n      return states.has(propName);\n    },\n    set(_, propName, value) {\n      set(propName, value);\n      return true;\n    }\n  });\n  const on = (eventName, callback) => {\n    handlers[eventName].push(callback);\n    return () => {\n      removeFromArray(handlers[eventName], callback);\n    };\n  };\n  const onChange = (propName, cb) => {\n    const unSet = on('set', (key, newValue) => {\n      if (key === propName) {\n        cb(newValue);\n      }\n    });\n    const unReset = on('reset', () => cb(defaultState[propName]));\n    return () => {\n      unSet();\n      unReset();\n    };\n  };\n  const use = (...subscriptions) => subscriptions.forEach(subscription => {\n    if (subscription.set) {\n      on('set', subscription.set);\n    }\n    if (subscription.get) {\n      on('get', subscription.get);\n    }\n    if (subscription.reset) {\n      on('reset', subscription.reset);\n    }\n  });\n  return {\n    state,\n    get,\n    set,\n    on,\n    onChange,\n    use,\n    dispose,\n    reset\n  };\n};\nconst removeFromArray = (array, item) => {\n  const index = array.indexOf(item);\n  if (index >= 0) {\n    array[index] = array[array.length - 1];\n    array.length--;\n  }\n};\nconst createStore = (defaultState, shouldUpdate) => {\n  const map = createObservableMap(defaultState, shouldUpdate);\n  stencilSubscription(map);\n  return map;\n};\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeCeil = Math.ceil,\n  nativeMax = Math.max;\n\n/**\n * The base implementation of `_.range` and `_.rangeRight` which doesn't\n * coerce arguments.\n *\n * @private\n * @param {number} start The start of the range.\n * @param {number} end The end of the range.\n * @param {number} step The value to increment or decrement by.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Array} Returns the range of numbers.\n */\nfunction baseRange(start, end, step, fromRight) {\n  var index = -1,\n    length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n    result = Array(length);\n  while (length--) {\n    result[fromRight ? length : ++index] = start;\n    start += step;\n  }\n  return result;\n}\nvar _baseRange = baseRange;\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject_1(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number' ? isArrayLike_1(object) && _isIndex(index, object.length) : type == 'string' && index in object) {\n    return eq_1(object[index], value);\n  }\n  return false;\n}\nvar _isIterateeCall = isIterateeCall;\n\n/**\n * Creates a `_.range` or `_.rangeRight` function.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new range function.\n */\nfunction createRange(fromRight) {\n  return function (start, end, step) {\n    if (step && typeof step != 'number' && _isIterateeCall(start, end, step)) {\n      end = step = undefined;\n    }\n    // Ensure the sign of `-0` is preserved.\n    start = toFinite_1(start);\n    if (end === undefined) {\n      end = start;\n      start = 0;\n    } else {\n      end = toFinite_1(end);\n    }\n    step = step === undefined ? start < end ? 1 : -1 : toFinite_1(step);\n    return _baseRange(start, end, step, fromRight);\n  };\n}\nvar _createRange = createRange;\n\n/**\n * Creates an array of numbers (positive and/or negative) progressing from\n * `start` up to, but not including, `end`. A step of `-1` is used if a negative\n * `start` is specified without an `end` or `step`. If `end` is not specified,\n * it's set to `start` with `start` then set to `0`.\n *\n * **Note:** JavaScript follows the IEEE-754 standard for resolving\n * floating-point values which can produce unexpected results.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {number} [start=0] The start of the range.\n * @param {number} end The end of the range.\n * @param {number} [step=1] The value to increment or decrement by.\n * @returns {Array} Returns the range of numbers.\n * @see _.inRange, _.rangeRight\n * @example\n *\n * _.range(4);\n * // => [0, 1, 2, 3]\n *\n * _.range(-4);\n * // => [0, -1, -2, -3]\n *\n * _.range(1, 5);\n * // => [1, 2, 3, 4]\n *\n * _.range(0, 20, 5);\n * // => [0, 5, 10, 15]\n *\n * _.range(0, -4, -1);\n * // => [0, -1, -2, -3]\n *\n * _.range(1, 4, 0);\n * // => [1, 1, 1]\n *\n * _.range(0);\n * // => []\n */\nvar range = _createRange();\nvar range_1 = range;\n\n/**\n * Hide items from main collection\n * But keep them in store\n */\nconst trimmedPlugin = store => ({\n  set(k, newVal) {\n    switch (k) {\n      case 'trimmed':\n        const proxy = store.get('proxyItems');\n        const trimmed = gatherTrimmedItems(newVal);\n        const newItems = proxy.reduce((result, v) => {\n          // check if present in new trimmed remove from items (filter)\n          if (!trimmed[v]) {\n            result.push(v);\n          }\n          return result;\n        }, []);\n        store.set('items', newItems);\n        break;\n    }\n  }\n});\nfunction gatherTrimmedItems(trimmedItems) {\n  const trimmed = {};\n  for (let trimmedKey in trimmedItems) {\n    // trimmed overweight not trimmed\n    for (let t in trimmedItems[trimmedKey]) {\n      trimmed[t] = trimmed[t] || trimmedItems[trimmedKey][t];\n    }\n  }\n  return trimmed;\n}\n\n/** Set stores data */\nfunction setStore(store, data) {\n  for (let key in data) {\n    store.set(key, data[key]);\n  }\n}\n\n/**\n * All items\n * Used as proxy for sorting\n * Keep order but do not modify final source\n */\nconst proxyPlugin = store => ({\n  set(k, newVal) {\n    if (!isProxy(k)) {\n      return;\n    }\n    /**\n     * Getting existing collection of items\n     * Mark indexes as visible\n     */\n    const oldItems = store.get('items').reduce((r, v) => {\n      r[v] = true;\n      return r;\n    }, {});\n    /**\n     * Check if new values where present in items\n     * Filter item collection according presense\n     */\n    const newItems = newVal.reduce((r, i) => {\n      if (oldItems[i]) {\n        r.push(i);\n      }\n      return r;\n    }, []);\n    store.set('items', newItems);\n  }\n});\nfunction isProxy(k) {\n  return k === 'proxyItems';\n}\nclass DataStore {\n  constructor(type) {\n    const store = this.dataStore = createStore({\n      items: [],\n      proxyItems: [],\n      source: [],\n      groupingDepth: 0,\n      groups: {},\n      type,\n      trimmed: {}\n    });\n    store.use(proxyPlugin(store));\n    store.use(trimmedPlugin(store));\n  }\n  get store() {\n    return this.dataStore;\n  }\n  /**\n   * full data source update\n   * @param source - data column/rgRow source\n   * @param grouping - grouping information if present\n   */\n  updateData(source, grouping, silent = false) {\n    // during full update we do drop trim\n    if (!silent) {\n      this.store.set('trimmed', {});\n    }\n    // clear items\n    this.store.set('items', []);\n    const items = range_1(0, (source === null || source === void 0 ? void 0 : source.length) || 0);\n    // set proxy first\n    setStore(this.store, {\n      source,\n      proxyItems: [...items]\n    });\n    // update data items\n    this.store.set('items', items);\n    // apply grooping if present\n    if (grouping) {\n      setStore(this.store, {\n        groupingDepth: grouping.depth,\n        groups: grouping.groups,\n        groupingCustomRenderer: grouping.customRenderer\n      });\n    }\n  }\n  addTrimmed(some) {\n    let trimmed = this.store.get('trimmed');\n    trimmed = Object.assign(Object.assign({}, trimmed), some);\n    setStore(this.store, {\n      trimmed\n    });\n  }\n  // local data update\n  setData(input) {\n    const data = Object.assign({}, input);\n    setStore(this.store, data);\n  }\n  refresh() {\n    const source = this.store.get('source');\n    this.store.set('source', [...source]);\n  }\n}\n/**\n * get physical index by virtual\n * @param store - store to process\n */\nfunction getPhysical(store, virtualIndex) {\n  const items = store.get('items');\n  return items[virtualIndex];\n}\n/**\n * get all visible items\n * @param store - store to process\n */\nfunction getVisibleSourceItem(store) {\n  const source = store.get('source');\n  return store.get('items').map(v => source[v]);\n}\n/**\n * get mapped item from source\n * @param store - store to process\n * @param virtualIndex - virtual index to process\n */\nfunction getSourceItem(store, virtualIndex) {\n  const items = store.get('items');\n  const source = store.get('source');\n  return source[items[virtualIndex]];\n}\n/**\n * set item to source\n * @param store  - store to process\n * @param modelByIndex - collection of rows with virtual indexes to setup\n */\nfunction setSourceByVirtualIndex(store, modelByIndex) {\n  const items = store.get('items');\n  const source = store.get('source');\n  for (let virtualIndex in modelByIndex) {\n    const realIndex = items[virtualIndex];\n    source[realIndex] = modelByIndex[virtualIndex];\n  }\n  store.set('source', [...source]);\n}\nfunction setItems(store, items) {\n  store.set('items', items);\n}\nfunction getSourceItemVirtualIndexByProp(store, prop) {\n  const items = store.get('items');\n  const source = store.get('source');\n  const physicalIndex = findIndex_1(source, {\n    prop\n  });\n  return items.indexOf(physicalIndex);\n}\nexport { DataStore as D, _isIterateeCall as _, getSourceItemVirtualIndexByProp as a, getVisibleSourceItem as b, createStore as c, setStore as d, getPhysical as e, findIndex_1 as f, getSourceItem as g, setItems as h, setSourceByVirtualIndex as s };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
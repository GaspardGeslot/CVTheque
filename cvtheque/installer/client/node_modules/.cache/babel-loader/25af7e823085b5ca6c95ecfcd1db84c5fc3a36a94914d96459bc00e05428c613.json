{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*!\n * Built by Revolist\n */\nimport { h } from '@stencil/core/internal/client';\nimport { c as createStore, d as setStore, b as getVisibleSourceItem, g as getSourceItem, s as setSourceByVirtualIndex } from './data.store.js';\nimport { G as GRID_INTERNALS, h as CELL_CLASS, i as DISABLED_CLASS } from './consts.js';\nconst GROUP_DEPTH = `${GRID_INTERNALS}-depth`;\nconst PSEUDO_GROUP_ITEM = `${GRID_INTERNALS}-name`;\nconst PSEUDO_GROUP_ITEM_ID = `${GRID_INTERNALS}-id`;\nconst PSEUDO_GROUP_ITEM_VALUE = `${GRID_INTERNALS}-value`;\nconst PSEUDO_GROUP_COLUMN = `${GRID_INTERNALS}-column`;\nconst GROUP_EXPANDED = `${GRID_INTERNALS}-expanded`;\nconst GROUP_ORIGINAL_INDEX = `${GRID_INTERNALS}-original-index`;\nconst GROUP_EXPAND_BTN = `group-expand`;\nconst GROUP_EXPAND_EVENT = `groupExpandClick`;\nconst GROUPING_ROW_TYPE = 'rgRow';\n\n/**\n * Gather data for grouping\n * @param array - flat data array\n * @param groupIds - ids of groups\n * @param expanded - potentially expanded items if present\n */\nfunction gatherGrouping(array, groupIds, {\n  prevExpanded,\n  expandedAll\n}) {\n  const groupedItems = new Map();\n  array.forEach((item, originalIndex) => {\n    const groupLevelValues = groupIds.map(groupId => item[groupId] || null);\n    const lastLevelValue = groupLevelValues.pop();\n    let currentGroupLevel = groupedItems;\n    groupLevelValues.forEach(value => {\n      if (!currentGroupLevel.has(value)) {\n        currentGroupLevel.set(value, new Map());\n      }\n      currentGroupLevel = currentGroupLevel.get(value);\n    });\n    if (!currentGroupLevel.has(lastLevelValue)) {\n      currentGroupLevel.set(lastLevelValue, []);\n    }\n    item[GROUP_ORIGINAL_INDEX] = originalIndex;\n    const lastLevelItems = currentGroupLevel.get(lastLevelValue);\n    lastLevelItems.push(item);\n  });\n  let itemIndex = -1;\n  const groupingDepth = groupIds.length;\n  // collapse all groups in the beginning\n  const trimmed = {};\n  // index mapping\n  const oldNewIndexMap = {};\n  // check if group header exists\n  const pseudoGroupTest = {};\n  const sourceWithGroups = [];\n  function flattenGroupMaps(groupedValues, parentIds, isExpanded) {\n    const depth = parentIds.length;\n    groupedValues.forEach((innerGroupedValues, groupId) => {\n      const levelIds = [...parentIds, groupId];\n      const mergedIds = levelIds.join(',');\n      const isGroupExpanded = isExpanded && (!!expandedAll || !!(prevExpanded === null || prevExpanded === void 0 ? void 0 : prevExpanded[mergedIds]));\n      sourceWithGroups.push({\n        [PSEUDO_GROUP_ITEM]: groupId,\n        [GROUP_DEPTH]: depth,\n        [PSEUDO_GROUP_ITEM_ID]: JSON.stringify(levelIds),\n        [PSEUDO_GROUP_ITEM_VALUE]: mergedIds,\n        [GROUP_EXPANDED]: isGroupExpanded\n      });\n      itemIndex += 1;\n      if (!isGroupExpanded && depth) {\n        trimmed[itemIndex] = true;\n      }\n      if (Array.isArray(innerGroupedValues)) {\n        innerGroupedValues.forEach(value => {\n          itemIndex += 1;\n          if (!isGroupExpanded) {\n            trimmed[itemIndex] = true;\n          }\n          oldNewIndexMap[value[GROUP_ORIGINAL_INDEX]] = itemIndex;\n          const pseudoGroupTestIds = levelIds.map((_value, index) => levelIds.slice(0, index + 1).join(','));\n          pseudoGroupTestIds.forEach(pseudoGroupTestId => {\n            if (!pseudoGroupTest[pseudoGroupTestId]) {\n              pseudoGroupTest[pseudoGroupTestId] = [];\n            }\n            pseudoGroupTest[pseudoGroupTestId].push(itemIndex);\n          });\n        });\n        sourceWithGroups.push(...innerGroupedValues);\n      } else {\n        flattenGroupMaps(innerGroupedValues, levelIds, isGroupExpanded);\n      }\n    });\n  }\n  flattenGroupMaps(groupedItems, [], true);\n  return {\n    sourceWithGroups,\n    depth: groupingDepth,\n    trimmed,\n    oldNewIndexMap,\n    childrenByGroup: pseudoGroupTest // used to get child items in group\n  };\n}\n\nfunction getGroupingName(rgRow) {\n  return rgRow && rgRow[PSEUDO_GROUP_ITEM];\n}\nfunction isGrouping(rgRow) {\n  return rgRow && typeof rgRow[PSEUDO_GROUP_ITEM] !== 'undefined';\n}\nfunction isGroupingColumn(column) {\n  return column && typeof column[PSEUDO_GROUP_COLUMN] !== 'undefined';\n}\nfunction measureEqualDepth(groupA, groupB) {\n  const ln = groupA.length;\n  let i = 0;\n  for (; i < ln; i++) {\n    if (groupA[i] !== groupB[i]) {\n      return i;\n    }\n  }\n  return i;\n}\nfunction getParsedGroup(id) {\n  const parseGroup = JSON.parse(id);\n  // extra precaution and type safe guard\n  if (!Array.isArray(parseGroup)) {\n    return null;\n  }\n  return parseGroup;\n}\n// check if items is child of current clicked group\nfunction isSameGroup(currentGroup, currentModel, nextModel) {\n  const nextGroup = getParsedGroup(nextModel[PSEUDO_GROUP_ITEM_ID]);\n  if (!nextGroup) {\n    return false;\n  }\n  const depth = measureEqualDepth(currentGroup, nextGroup);\n  return currentModel[GROUP_DEPTH] < depth;\n}\nfunction isHiddenStore(pos) {\n  return pos === EMPTY_INDEX;\n}\nfunction nextCell(cell, lastCell) {\n  const nextItem = {};\n  let types = ['x', 'y'];\n  // previous item check\n  for (let t of types) {\n    if (cell[t] < 0) {\n      nextItem[t] = cell[t];\n      return nextItem;\n    }\n  }\n  // next item check\n  for (let t of types) {\n    if (cell[t] >= lastCell[t]) {\n      nextItem[t] = cell[t] - lastCell[t];\n      return nextItem;\n    }\n  }\n  return null;\n}\nfunction cropCellToMax(cell, lastCell) {\n  const newCell = Object.assign({}, cell);\n  let types = ['x', 'y'];\n  // previous item check\n  for (let t of types) {\n    if (cell[t] < 0) {\n      newCell[t] = 0;\n    }\n  }\n  // next item check\n  for (let t of types) {\n    if (cell[t] >= lastCell[t]) {\n      newCell[t] = lastCell[t] - 1;\n    }\n  }\n  return newCell;\n}\nfunction getRange(start, end) {\n  return start && end ? {\n    x: Math.min(start.x, end.x),\n    y: Math.min(start.y, end.y),\n    x1: Math.max(start.x, end.x),\n    y1: Math.max(start.y, end.y)\n  } : null;\n}\nfunction isRangeSingleCell(a) {\n  return a.x === a.x1 && a.y === a.y1;\n}\nfunction defaultState() {\n  return {\n    range: null,\n    tempRange: null,\n    tempRangeType: null,\n    focus: null,\n    edit: null,\n    lastCell: null\n  };\n}\nclass SelectionStore {\n  constructor() {\n    this.unsubscribe = [];\n    this.store = createStore(defaultState());\n    this.store.on('set', (key, newVal) => {\n      if (key === 'tempRange' && !newVal) {\n        this.store.set('tempRangeType', null);\n      }\n    });\n  }\n  onChange(propName, cb) {\n    this.unsubscribe.push(this.store.onChange(propName, cb));\n  }\n  clearFocus() {\n    setStore(this.store, {\n      focus: null,\n      range: null,\n      edit: null,\n      tempRange: null\n    });\n  }\n  setFocus(focus, end) {\n    setStore(this.store, {\n      focus,\n      range: getRange(focus, end),\n      edit: null,\n      tempRange: null\n    });\n  }\n  setTempArea(range) {\n    setStore(this.store, {\n      tempRange: range === null || range === void 0 ? void 0 : range.area,\n      tempRangeType: range === null || range === void 0 ? void 0 : range.type,\n      edit: null\n    });\n  }\n  clearTemp() {\n    setStore(this.store, {\n      tempRange: null\n    });\n  }\n  /** Can be applied from selection change or from simple keyboard change clicks */\n  setRangeArea(range) {\n    setStore(this.store, {\n      range,\n      edit: null,\n      tempRange: null\n    });\n  }\n  setRange(start, end) {\n    this.setRangeArea(getRange(start, end));\n  }\n  setLastCell(lastCell) {\n    setStore(this.store, {\n      lastCell\n    });\n  }\n  setEdit(val) {\n    const focus = this.store.get('focus');\n    if (focus && typeof val === 'string') {\n      setStore(this.store, {\n        edit: {\n          x: focus.x,\n          y: focus.y,\n          val\n        }\n      });\n      return;\n    }\n    setStore(this.store, {\n      edit: null\n    });\n  }\n  dispose() {\n    this.unsubscribe.forEach(f => f());\n    this.store.dispose();\n  }\n}\nconst EMPTY_INDEX = -1;\nclass SelectionStoreConnector {\n  constructor() {\n    // dirty flag required to cleanup whole store in case visibility of panels changed\n    this.dirty = false;\n    this.stores = {};\n    this.columnStores = {};\n    this.rowStores = {};\n    this.sections = [];\n  }\n  get focusedStore() {\n    var _a;\n    for (let y in this.stores) {\n      for (let x in this.stores[y]) {\n        const focused = (_a = this.stores[y][x]) === null || _a === void 0 ? void 0 : _a.store.get('focus');\n        if (focused) {\n          return {\n            entity: this.stores[y][x],\n            cell: focused,\n            position: {\n              x: parseInt(x, 10),\n              y: parseInt(y, 10)\n            }\n          };\n        }\n      }\n    }\n    return null;\n  }\n  get edit() {\n    var _a;\n    return (_a = this.focusedStore) === null || _a === void 0 ? void 0 : _a.entity.store.get('edit');\n  }\n  get focused() {\n    var _a;\n    return (_a = this.focusedStore) === null || _a === void 0 ? void 0 : _a.entity.store.get('focus');\n  }\n  get selectedRange() {\n    var _a;\n    return (_a = this.focusedStore) === null || _a === void 0 ? void 0 : _a.entity.store.get('range');\n  }\n  registerSection(e) {\n    if (!e) {\n      this.sections.length = 0;\n      // some elements removed, rebuild stores\n      this.dirty = true;\n      return;\n    }\n    if (this.sections.indexOf(e) === -1) {\n      this.sections.push(e);\n    }\n  }\n  // check if require to cleanup all stores\n  beforeUpdate() {\n    if (this.dirty) {\n      for (let y in this.stores) {\n        for (let x in this.stores[y]) {\n          this.stores[y][x].dispose();\n        }\n      }\n      this.dirty = false;\n    }\n  }\n  registerColumn(x) {\n    // if hidden just create store\n    if (isHiddenStore(x)) {\n      return new SelectionStore();\n    }\n    if (this.columnStores[x]) {\n      return this.columnStores[x];\n    }\n    this.columnStores[x] = new SelectionStore();\n    return this.columnStores[x];\n  }\n  registerRow(y) {\n    // if hidden just create store\n    if (isHiddenStore(y)) {\n      return new SelectionStore();\n    }\n    if (this.rowStores[y]) {\n      return this.rowStores[y];\n    }\n    this.rowStores[y] = new SelectionStore();\n    return this.rowStores[y];\n  }\n  /**\n   * Cross store proxy, based on multiple dimensions\n   */\n  register({\n    x,\n    y\n  }) {\n    var _a, _b;\n    // if hidden just create store\n    if (isHiddenStore(x) || isHiddenStore(y)) {\n      return new SelectionStore();\n    }\n    if (!this.stores[y]) {\n      this.stores[y] = {};\n    }\n    if (this.stores[y][x]) {\n      // Store already registered. Do not register twice\n      return this.stores[y][x];\n    }\n    this.stores[y][x] = new SelectionStore();\n    // proxy update\n    (_a = this.stores[y][x]) === null || _a === void 0 ? void 0 : _a.onChange('range', c => {\n      this.columnStores[x].setRangeArea(c);\n      this.rowStores[y].setRangeArea(c);\n    });\n    // clean up on remove\n    (_b = this.stores[y][x]) === null || _b === void 0 ? void 0 : _b.store.on('dispose', () => {\n      var _a, _b;\n      (_a = this.columnStores[x]) === null || _a === void 0 ? void 0 : _a.dispose();\n      (_b = this.rowStores[y]) === null || _b === void 0 ? void 0 : _b.dispose();\n      delete this.rowStores[y];\n      delete this.columnStores[x];\n      if (this.stores[y]) {\n        delete this.stores[y][x];\n      }\n      // clear empty rows\n      if (!Object.keys(this.stores[y] || {}).length) {\n        delete this.stores[y];\n      }\n    });\n    return this.stores[y][x];\n  }\n  setEditByCell({\n    x,\n    y\n  }, editCell) {\n    const store = this.stores[y][x];\n    this.focus(store, {\n      focus: editCell,\n      end: editCell\n    });\n    this.setEdit('');\n  }\n  focus(store, {\n    focus,\n    end\n  }) {\n    let currentStorePointer;\n    // clear all stores focus leave only active one\n    for (let y in this.stores) {\n      for (let x in this.stores[y]) {\n        const s = this.stores[y][x];\n        // clear other stores, only one area can be selected\n        if (s !== store) {\n          s.clearFocus();\n        } else {\n          currentStorePointer = {\n            x: parseInt(x, 10),\n            y: parseInt(y, 10)\n          };\n        }\n      }\n    }\n    if (!currentStorePointer) {\n      return;\n    }\n    // check is focus in next store\n    const lastCell = store.store.get('lastCell');\n    // item in new store\n    const nextItem = nextCell(focus, lastCell);\n    let nextStore;\n    if (nextItem) {\n      for (let i in nextItem) {\n        let type = i;\n        let stores;\n        switch (type) {\n          case 'x':\n            stores = this.getXStores(currentStorePointer.y);\n            break;\n          case 'y':\n            stores = this.getYStores(currentStorePointer.x);\n            break;\n        }\n        if (nextItem[type] >= 0) {\n          nextStore = stores[++currentStorePointer[type]];\n        } else {\n          nextStore = stores[--currentStorePointer[type]];\n          const nextLastCell = nextStore === null || nextStore === void 0 ? void 0 : nextStore.store.get('lastCell');\n          if (nextLastCell) {\n            nextItem[type] = nextLastCell[type] + nextItem[type];\n          }\n        }\n      }\n    }\n    // if next store present - update\n    if (nextStore) {\n      let item = Object.assign(Object.assign({}, focus), nextItem);\n      this.focus(nextStore, {\n        focus: item,\n        end: item\n      });\n      return;\n    }\n    focus = cropCellToMax(focus, lastCell);\n    end = cropCellToMax(focus, lastCell);\n    store.setFocus(focus, end);\n  }\n  clearAll() {\n    var _a;\n    for (let y in this.stores) {\n      for (let x in this.stores[y]) {\n        (_a = this.stores[y][x]) === null || _a === void 0 ? void 0 : _a.clearFocus();\n      }\n    }\n  }\n  setEdit(val) {\n    if (!this.focusedStore) {\n      return;\n    }\n    this.focusedStore.entity.setEdit(val);\n  }\n  getXStores(y) {\n    return this.stores[y];\n  }\n  getYStores(x) {\n    const stores = {};\n    for (let i in this.stores) {\n      stores[i] = this.stores[i][x];\n    }\n    return stores;\n  }\n}\nclass ColumnService {\n  constructor(dataStore, source) {\n    this.dataStore = dataStore;\n    this.source = source;\n    this.unsubscribe = [];\n    this.hasGrouping = false;\n    this.unsubscribe.push(source.onChange('source', s => this.checkGrouping(s)));\n    this.checkGrouping(source.get('source'));\n  }\n  get columns() {\n    return getVisibleSourceItem(this.source);\n  }\n  checkGrouping(cols) {\n    for (let rgCol of cols) {\n      if (isGroupingColumn(rgCol)) {\n        this.hasGrouping = true;\n        return;\n      }\n      this.hasGrouping = false;\n    }\n  }\n  isReadOnly(r, c) {\n    var _a;\n    const readOnly = (_a = this.columns[c]) === null || _a === void 0 ? void 0 : _a.readonly;\n    if (typeof readOnly === 'function') {\n      const data = this.rowDataModel(r, c);\n      return readOnly(data);\n    }\n    return readOnly;\n  }\n  static doMerge(existing, extra) {\n    let props = Object.assign(Object.assign({}, extra), existing);\n    // extend existing props\n    if (extra.class) {\n      if (typeof extra.class === 'object' && typeof props.class === 'object') {\n        props.class = Object.assign(Object.assign({}, extra.class), props.class);\n      } else if (typeof extra.class === 'string' && typeof props.class === 'object') {\n        props.class[extra.class] = true;\n      } else if (typeof props.class === 'string') {\n        props.class += ' ' + extra.class;\n      }\n    }\n    if (extra.style) {\n      props.style = Object.assign(Object.assign({}, extra.style), props.style);\n    }\n    return props;\n  }\n  mergeProperties(r, c, defaultProps) {\n    var _a;\n    const cellClass = {\n      [CELL_CLASS]: true,\n      [DISABLED_CLASS]: this.isReadOnly(r, c)\n    };\n    let props = Object.assign(Object.assign({}, defaultProps), {\n      class: cellClass\n    });\n    const extraPropsFunc = (_a = this.columns[c]) === null || _a === void 0 ? void 0 : _a.cellProperties;\n    if (extraPropsFunc) {\n      const data = this.rowDataModel(r, c);\n      const extra = extraPropsFunc(data);\n      if (!extra) {\n        return props;\n      }\n      return ColumnService.doMerge(props, extra);\n    }\n    return props;\n  }\n  customRenderer(_r, c, model) {\n    var _a;\n    const tpl = (_a = this.columns[c]) === null || _a === void 0 ? void 0 : _a.cellTemplate;\n    if (tpl) {\n      return tpl(h, model);\n    }\n    return;\n  }\n  getRowClass(r, prop) {\n    const model = getSourceItem(this.dataStore, r) || {};\n    return model[prop] || '';\n  }\n  getCellData(r, c) {\n    const data = this.rowDataModel(r, c);\n    return ColumnService.getData(data.model[data.prop]);\n  }\n  getSaveData(rowIndex, c, val) {\n    if (typeof val === 'undefined') {\n      val = this.getCellData(rowIndex, c);\n    }\n    const data = this.rowDataModel(rowIndex, c);\n    return {\n      prop: data.prop,\n      rowIndex,\n      val,\n      model: data.model,\n      type: this.dataStore.get('type')\n    };\n  }\n  getCellEditor(_r, c, editors) {\n    var _a;\n    const editor = (_a = this.columns[c]) === null || _a === void 0 ? void 0 : _a.editor;\n    if (!editor) {\n      return undefined;\n    }\n    // reference\n    if (typeof editor === 'string') {\n      return editors[editor];\n    }\n    return editor;\n  }\n  rowDataModel(rowIndex, c) {\n    const column = this.columns[c];\n    const prop = column === null || column === void 0 ? void 0 : column.prop;\n    const model = getSourceItem(this.dataStore, rowIndex) || {};\n    return {\n      prop,\n      model,\n      data: this.dataStore.get('source'),\n      column,\n      rowIndex\n    };\n  }\n  getRangeData(d) {\n    const changed = {};\n    // get original length sizes\n    const copyColLength = d.oldProps.length;\n    const copyFrom = this.copyRangeArray(d.oldRange, d.oldProps, this.dataStore);\n    const copyRowLength = copyFrom.length;\n    // rows\n    for (let rowIndex = d.newRange.y, i = 0; rowIndex < d.newRange.y1 + 1; rowIndex++, i++) {\n      // copy original data link\n      const copyRow = copyFrom[i % copyRowLength];\n      // columns\n      for (let colIndex = d.newRange.x, j = 0; colIndex < d.newRange.x1 + 1; colIndex++, j++) {\n        // check if old range area\n        if (rowIndex >= d.oldRange.y && rowIndex <= d.oldRange.y1 && colIndex >= d.oldRange.x && colIndex <= d.oldRange.x1) {\n          continue;\n        }\n        const p = this.columns[colIndex].prop;\n        const currentCol = j % copyColLength;\n        /** if can write */\n        if (!this.isReadOnly(rowIndex, colIndex)) {\n          /** to show before save */\n          if (!changed[rowIndex]) {\n            changed[rowIndex] = {};\n          }\n          changed[rowIndex][p] = copyRow[currentCol];\n        }\n      }\n    }\n    return changed;\n  }\n  getTransformedDataToApply(start, data) {\n    const changed = {};\n    const copyRowLength = data.length;\n    const colLength = this.columns.length;\n    const rowLength = this.dataStore.get('items').length;\n    // rows\n    let rowIndex = start.y;\n    let maxCol = 0;\n    for (let i = 0; rowIndex < rowLength && i < copyRowLength; rowIndex++, i++) {\n      // copy original data link\n      const copyRow = data[i % copyRowLength];\n      const copyColLength = (copyRow === null || copyRow === void 0 ? void 0 : copyRow.length) || 0;\n      // columns\n      let colIndex = start.x;\n      for (let j = 0; colIndex < colLength && j < copyColLength; colIndex++, j++) {\n        const p = this.columns[colIndex].prop;\n        const currentCol = j % colLength;\n        /** if can write */\n        if (!this.isReadOnly(rowIndex, colIndex)) {\n          /** to show before save */\n          if (!changed[rowIndex]) {\n            changed[rowIndex] = {};\n          }\n          changed[rowIndex][p] = copyRow[currentCol];\n        }\n      }\n      maxCol = Math.max(maxCol, colIndex - 1);\n    }\n    const range = getRange(start, {\n      y: rowIndex - 1,\n      x: maxCol\n    });\n    return {\n      changed,\n      range\n    };\n  }\n  applyRangeData(data) {\n    const items = {};\n    for (let rowIndex in data) {\n      const oldModel = items[rowIndex] = getSourceItem(this.dataStore, parseInt(rowIndex, 10));\n      for (let prop in data[rowIndex]) {\n        oldModel[prop] = data[rowIndex][prop];\n      }\n    }\n    setSourceByVirtualIndex(this.dataStore, items);\n  }\n  getRangeStaticData(d, value) {\n    const changed = {};\n    // rows\n    for (let rowIndex = d.y, i = 0; rowIndex < d.y1 + 1; rowIndex++, i++) {\n      // columns\n      for (let colIndex = d.x, j = 0; colIndex < d.x1 + 1; colIndex++, j++) {\n        const p = this.columns[colIndex].prop;\n        /** if can write */\n        if (!this.isReadOnly(rowIndex, colIndex)) {\n          /** to show before save */\n          if (!changed[rowIndex]) {\n            changed[rowIndex] = {};\n          }\n          changed[rowIndex][p] = value;\n        }\n      }\n    }\n    return changed;\n  }\n  copyRangeArray(range, rangeProps, store) {\n    const toCopy = [];\n    for (let i = range.y; i < range.y1 + 1; i++) {\n      const rgRow = [];\n      for (let prop of rangeProps) {\n        const item = getSourceItem(store, i);\n        rgRow.push(item[prop]);\n      }\n      toCopy.push(rgRow);\n    }\n    return toCopy;\n  }\n  static getData(val) {\n    if (typeof val === 'undefined' || val === null) {\n      return '';\n    }\n    return val.toString();\n  }\n  destroy() {\n    this.unsubscribe.forEach(f => f());\n  }\n}\nexport { ColumnService as C, EMPTY_INDEX as E, GROUP_EXPANDED as G, PSEUDO_GROUP_ITEM_VALUE as P, SelectionStoreConnector as S, getParsedGroup as a, isSameGroup as b, GROUP_DEPTH as c, PSEUDO_GROUP_ITEM_ID as d, GROUPING_ROW_TYPE as e, PSEUDO_GROUP_COLUMN as f, getGroupingName as g, GROUP_EXPAND_EVENT as h, isGrouping as i, gatherGrouping as j, isGroupingColumn as k, GROUP_EXPAND_BTN as l, PSEUDO_GROUP_ITEM as m, getRange as n, isRangeSingleCell as o };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}